export default {"blog_list":[{"slug":"my-programming-story","frontmatter":{"title":"내가 코딩을 해온 이야기","excerpt":"제대로 된 로봇을 코딩하고 싶은 게 시작이었는데. 어쩌다 여기까지 왔는지 이야기해보려 합니다.","date":"2021-07-20T15:56:54.826458","author":"탐정토끼(Taehee Kim)","tag":"초고, 이야기"},"html":"<p>이따금씩 제가 어떻게 코딩을 시작했는지? 아니면 어떤 사람인지 궁금해하시는 분들이 있습니다. 그런 분들을 위해 TMI 솔직한 이야기를 적어봤습니다. 저도 특이하고 이상한 사람이지만, 동시에 평범하게 삽질하고 좌절하는 사람이라는 걸 알아주시면 좋겠습니다.</p>\n<h2 id=\"부모님은-프로그래머셨고-컴퓨터-학원에서-자랐다\">부모님은 프로그래머셨고, 컴퓨터 학원에서 자랐다.</h2>\n<p>이런 이야기는 어린 시절부터 시작하죠.</p>\n<p>제 부모님은 프로그래머이셨습니다. 그게 영향을 미치긴 했을 겁니다.</p>\n<p>어머니는 컴퓨터 학원을 하셨고, 저는 초등학교에 들어가기도 전부터 컴퓨터 학원에서 게임을 했습니다. 전화선으로 모뎀을 하던 시절도 기억나고요. 처음 광랜을 깔고 나서 아버지가 설명하시던 것도 기억이 납니다.</p>\n<p>집에는 아버지가 쓰신 두꺼운 프로그래밍 책이 있었지만, \"웹 마스터\"나 \"클리퍼 윈도우 프로그래밍\" 같은 주제였죠. 2008년에 아버지가 다니던 회사가 망해서 집에서 웹 사이트만 만들고 계시는 것도 보았습니다. 아버지는 그때도 지금도 JSP와 나모 웹 에디터를 쓰십니다.</p>\n<h2 id=\"친구들이-신기해하는-로봇을-만들고-싶었다\">친구들이 신기해하는 로봇을 만들고 싶었다.</h2>\n<p>제가 초등학생일 시절에 학교 방과후 활동으로 '로봇 제작'을 했습니다. \"하늘아이\"라는 회사였는데요. 라인트레이서라던가 이것저것 만들어 봤습니다. 특이한 블록코딩 시스템을 사용했는데, UI가 너무 비직관적이고 추상적이라 전혀 이해하질 못했습니다. 학년이 올라가면서 단계가 올라가고, 더 복잡한 로봇 키트를 만들었고요. 대회도 나갔습니다. 납땜하다가 부품이 타버려서 실패하고 돌아왔던 걸로 기억합니다.</p>\n<p>로봇을 만들면서 여러모로 즐거웠습니다. 내가 만든 게 돌아가고, 적외선 리모컨으로 조종도 하고요. 로봇을 가져오는 날이면 애들이 신기해하면서 자기도 해보겠다고 난리였습니다. 그 관심이 기쁘기도 하면서도, 저는 왕따였기 때문에 로봇이 부서지기도 하고 그랬죠.</p>\n<p>중학생이 되고 로봇 방과후도 사라졌습니다. 저는 좀 더 제대로 된 로봇을 만들고 싶었습니다. 도서관에 가서 책을 찾아보려는데, 너무 키가 작아서 어떤 누나가 꺼내줬던 게 기억이 납니다. 그 책은 [AVR 바이블]이었습니다.</p>\n<h2 id=\"avr과-c는-너무-어려웠다\">AVR과 C는 너무 어려웠다...</h2>\n<p>그때는 아두이노 같은 게 없었습니다. AVR은 대학생들이 졸작용으로 많이 쓰는 저렴한 칩인데, 아두이노도 AVR 기반입니다. 그래서 C로 직접 어떤 핀에 어떻게 신호가 들어오고 어떻게 나가는지... 저수준에서 직접 코딩해야했습니다. 기판도 부품을 사서 직접 납땜을 했습니다.</p>\n<p>어떻게 코드를 짰는지 기억은 잘 나지 않습니다. 이리저리 시도해봤지만 로봇은 돌아가지 않았습니다. 그게 납땜을 잘못했는지, 에러가 나면서 부품이 타버린 건지는 모르겠습니다. 아버지도 제 코드를 보고 고쳐보려 하셨지만, 결국 원인은 찾지 못하고 실패로 끝났습니다.</p>\n<h2 id=\"자바랑-sql만-할-줄-알면-된다\">자바랑 SQL만 할 줄 알면 된다!</h2>\n<p>저희 아버지가 늘 하시는 이야기 중에 하나입니다. 아버지는 제가 프로그래머가 되시길 바랬습니다. [자바의 정석]을 사서 공부했습니다. 책 내용은 그리 나쁘지 않았는데, 이게 실제로 뭘 만들어보지 않으니 재미가 없었습니다. Swing으로 이것저것 해보려던 기억 정도입니다.</p>\n<p>하지만 아버지의 바람과 달리, 저는 프로그래머가 될 생각이 없었습니다. 대신 저는 우연한 계기로 물리학에 빠지게 되었죠. -이건 또 이야기할 기회가 있을 겁니다.-</p>\n<p>고등학생 때 저는 물리학이 너무 좋았습니다. 진로를 고민하면서 복잡계 쪽이나, 물리 교사, 아니면 2014년 당시에 신생 학문이었던 \"데이터 과학\"은 어떨지 고민했습니다. 복잡계는 참 신기하고 미래가 있는 분야처럼 보였습니다. 이른바 통섭! 열풍과 함께 \"새로운 물리학은 사회 과학도 설명할 수 있지 않을까?\"하는 기대가 커졌으니까요. [카오스], [과학 콘서트], [복잡계 개론], [사회적 원자], [구글 신은 모든 것을 알고 있다], [넥서스], [사회적 원자], [링크] 같은 책을 열심히 읽었던 기억이 납니다.</p>\n<h2 id=\"빅데이터와-파이썬\">빅데이터와 파이썬</h2>\n<p>대학에 들어가고 갑자기 \"빅데이터\" 광풍이 몰아쳤습니다. 당시의 빅데이터는 지금처럼 \"딥러닝\" \"인공지능\"과는 좀 달랐습니다. 제가 좋아하는 물리학, 특히 복잡계랑 이런저런 관련이 있었습니다. 삼성 경제 연구소 SERI에서 [빅데이터 경영을 바꾸다]를 쓴 채승병 연구원은 원래 복잡계 물리학을 하시던 분입니다. 복잡계 물리학 연구자들은 하나 둘 씩 빅데이터 열풍에 탑승하기 시작했습니다.</p>\n<p>저도 데이터 과학을 좀 해봐야겠다고 생각해서 여러 책을 사서 읽고 공부했습니다. 그때는 통계 진영의 R과 전통 프로그래밍에 가까운 파이썬이 양강 구도를 이루고 있었는데요. 그래서 통계학도 공부했고 R도 어느 정도 다루게 되었습니다. 한편으로는 파이썬으로 Pandas나 Numpy, Scikit-Learn, NLTK, Matplot 등을 다루는 건 예나 지금이나 비슷했습니다.</p>\n<p>하지만 흐름은 점차 \"인공 신경망\", 즉 \"딥러닝\" 쪽으로 기울기 시작했습니다. 저는 딥러닝에 여러모로 관심이 있긴 했지만. 잘 모르기도 했고, 좀 공부한 뒤에는 불만을 느끼기 시작했습니다. 일단 피드백이 너무 느렸거든요. 어떤 모델의 원리를 머릿 속으로 생각하고 고민하고 기법을 적용해도. 모델이 학습하는 데에는 너무 오랜 시간이 걸렸습니다.</p>\n<h2 id=\"생활코딩으로-웹-개발을-시작하다\">생활코딩으로 웹 개발을 시작하다.</h2>\n<p>하루는 동생이 생활코딩이라는 사이트를 알려줬습니다. 취미삼아 HTML, CSS 기초부터 시작해서 웹 개발을 해보기 시작했습니다. 생각보다 재미있었습니다. 간단하게 Node도 써보고, 파이썬 Django와 Flask를 배워서 해봤습니다. 간단하고 이것저것 해보기 좋은 프레임워크였죠.</p>\n<p>이고잉님은 지금 생각해도 좀 독보적인 분입니다. 학습자의 마음을 헤아리는 말 한 마디 한 마디 하며, \"이걸 10억 번 해야한다고 생각해보세요!\"라는 명대사로 \"중복의 제거\" 같은 개념들을 제 마음에 심어주셨죠.</p>\n<p>하지만 저는 여전히 웹 개발자가 될 생각은 없었습니다.</p>\n<h2 id=\"군대에서-엑셀-개발자가-되다\">군대에서 엑셀 개발자가 되다.</h2>\n<p>저는 군대 갔고 통신병 보직을 받았습니다. 저희 부대에서 통신병은 행정병 일도 같이 했었는데요. 선임들은 간단한 엑셀 수식을 걸어서 이런저런 일을 편하게 하고 있었습니다. 저도 매일 엑셀 도움말을 보면서 이런저런 함수와 단축키를 익혔죠</p>\n<p>그 모습을 보던 행정 보급관님께서 하루는 저에게 \"경작서를 엑셀로 짤 수 있겠느냐?\"고 물어보셨습니다. 이게 제 첫 임무의 시작이었습니다.</p>\n<p>상황을 설명하면 이렇습니다.</p>\n<p>경작서는 몇 시부터 몇 시까지 누가 불침번을 설지, 당번을 정하는 계획표입니다. 모든 병사들이 골고루 돌아가면서 근무를 서야 불만이 없습니다. 문제는 당시에는 이 모든 걸 사람 머리로 해야했고, 경작서 양식에 손으로 기입했습니다. 실수로 누가 휴가를 가는데 근무를 편성하거나... 근무표를 짜놨는데 누가 휴가를 가서 근무표를 수정해야하면... 지옥이었죠. 상사이신 행정보급관님이 겨우 이런 업무 때문에 매일 야근을 하셨습니다. 아직 유치원생이신 아드님에게 전화가 걸려와 \"아빠 언제와. ㅠㅠ 나 혼자야. 무서워. 엄마도 아직 안 왔어.\" 같은 대화를 옆에서 듣고 있으면, 슬플 따름이었습니다.</p>\n<p>제 선임들도 이걸 시도해봤지만, 모두 실패했습니다. 군대에서는 파이썬은 물론이고, 엑셀의 VBA도 보안 때문에 금지되어 있습니다. 남은 건 오직 기본 함수들 뿐이죠. 이걸로 복잡한 프로그램을 작성할 수 있을까요? 저도 마찬가지로 실패했습니다.</p>\n<p>체념하고 재활용 쓰레기를 버리러 가는 중이었습니다. 그러다 머리 속에 유레카가 떠올랐습니다. 기능이 없으면 만들면 되죠. 기본 함수들을 조합해서 제가 원하는 기능을 만들 방법이 떠오른 것이었습니다!</p>\n<p>엑셀은 react처럼 반응형으로 동작합니다. 그때는 잘 몰랐지만, 저는 근무를 짜는 달력(상태)과 이를 경작서 문서 양식에 맞게 변환하는 시트를 분리했습니다. 그래서 달력에서 편하게 근무를 짤 수 있었고요. 누가 언제부터 언제까지 휴가를 가고, 근무를 몇 번 섰는지도 통계 대시보드를 만들어 넣었습니다.</p>\n<p>제가 만든 첫 엑셀 앱은 성공을 거뒀습니다. 점점 기능을 추가하면서 발전했고, 버그도 고쳤습니다. 예를들면 초기 버전에서는 30일이냐 31일이냐, 사람이 몇 명인지 등을 하드 코딩했습니다. 부대에 신입이 들어오고, 말년은 전역할 때마다 관련된 값을 바꿔줘야했죠. 이걸 derived하게 계산한 값으로 고쳤습니다.</p>\n<p>이 경작서 양식은 근처에 다른 부대로도 수출되고, 저는 출장AS를 다니기도 했습니다. 무엇보다 기쁜 일은 뭐였냐면, 나중에 저희 행보관님의 가족 분들이 부대를 방문하셨을 때였습니다. 행보관님이 저를 \"내 야근을 없애준 그 친구\"로 소개해주셨거든요.</p>\n<p>코딩이 사용자에게 가치를 전할 수 있다는 걸, 몸소 느끼고 체험했던 경험이었습니다.</p>\n<h2 id=\"사무-자동화-운동을-벌이다\">사무 자동화 운동을 벌이다.</h2>\n<p>한 번 성공을 맛본 저는 더 많은 걸 자동화하고 싶어졌습니다. 예를들어 휴가나 진급 같은 인사 관련 서류를 만들 때, 인사 행정병들은 병사들의 이름, 군번, 계급 같은 인적사항을 찾아서 하나하나 옮겨 적었습니다. 그래서 담당 병사들은 보통 이런 연명부를 통째로 외워야 했습니다. 역시 야근을 하지 않는 날이 없었죠.</p>\n<p>VLOOKUP과 여러 기능을 동원해서 자동으로 인사 명령지를 채워주는 친구를 만들었습니다. 여기서도 문제는 있었는데요. 군번은 유일키지만, 이름은 동명이인이 있을 수 있습니다. 문제는 군번을 외우기 힘들어서 이 프로그램을 만들었다는 것이죠. 동명이인을 따로 빼서 사람이 처리할 수 있도록 만들었습니다.</p>\n<p>이런 식으로 군수, 병기, 교육, 각종 현황 관리 등등... 다양한 업무를 자동화해나가던 중. 문제가 생겼습니다.</p>\n<h2 id=\"사람들의-말을-들어야한다\">사람들의 말을 들어야한다.</h2>\n<p>한 간부님이 저를 부르셨습니다. 제가 만든 양식이 편리하지만, 상부에서 내려준 공식 양식과 달라서 쓸 수 없다는 것이었죠. 처음에는 당황스러웠지만, 금세 해결책을 찾았습니다. 이 편리한 양식으로 관리하면, 알아서 '보고용' 양식으로 변환해주도록 만들었습니다.</p>\n<p>그 다음에는 새 양식이 불편하다, 사용법을 잘 모르겠다는 사람들이 나왔습니다. 사실 자동화는 편리하지만, 낯설기도 합니다. 지나치게 추상화를 하면 뭔가 간결하고 돌아가긴 하는데, 마치 이해하기 어려운 함수형 코드처럼 되죠. 이때도 이런 트레이드 오프를 고민한 끝에, 핵심이 아닌 기능들을 버렸습니다. 익숙한 핵심 기능만 남겨놓으니 직관적이고 편리한 친구가 되었습니다.</p>\n<p>하지만 여전히 새 양식은 잘 퍼지지 않았습니다. 이 양식은 저희 중대 뿐만 아니라 저희 대대 전체에서 쓰는 양식이었습니다. 대대에서 공식적으로 새 양식을 쓰기로 결정했지만, 옛날 양식을 써서 제출하는 사람들이 많았습니다.</p>\n<p>저는 각 중대를 돌면서 담당자(당직 근무자)를 만났습니다. 새 양식을 보여주고, 지금까지 우리가 삽질했던 걸 얼마나 쉽고 편리하게 할 수 있는지 보여줬습니다. 사실 모두 호의적인 반응을 보였습니다. 이런 양식이 있는 줄 몰랐다던가. 저번에 양식을 받았는데 어디에 뒀는지 모르겠다는 식의 답을 받았죠. 그래서 양식이 정착될 때까지 매번 파일을 전파해주고, 같이 사용법도 적어놓았습니다.</p>\n<p>어느새 새 양식은 널리 퍼졌고, 당연하게 여겨졌습니다.</p>\n<p>저는 전문하사로 7개월을 더 있었습니다. 후임들을 교육하고 단축키와 엑셀 함수를 알려줬습니다. 제가 없어도 사람들이 제 양식을 고치고 수정하는 모습을 보며. 저는 사회로 돌아왔습니다.</p>\n<h2 id=\"첫-팀-프로젝트에서-고통을-맛보다\">첫 팀 프로젝트에서 고통을 맛보다.</h2>\n<p>사회로 돌아오고, 이제 졸업이 얼마남지 않게 되었습니다. 저는 교내에 데이터 분석 스터디를 만들어 공부를 했습니다. 그러다 한 스터디원님이 같이 프로젝트를 해보자고 권유를 하셨죠. 급히 회의를 해서 기획서를 만들었고요. 제 첫 프로젝트인 [TRAS 한국 여행자 후기 분석 시스템]을 시작했습니다.</p>\n<p>결말부터 말하자면 프로젝트는 혼돈 그 자체였습니다. 팀장은 소프트웨어 학과 4학년인 분이었는데. 프런트도 백엔드도 할 줄 몰랐습니다. 딥러닝 모델을 만들겠다고 했는데, 깃허브에 커밋이 올라오질 않았습니다.</p>\n<p>그나마 손톱만한 지식을 가지고 있는 건 저 밖에 없었습니다. 성실하고 열정이 있으신 다른 팀원 분과 둘이서 크롤링하고, 전처리하고, 모델을 만들고, 백엔드 서버를 만들고, 프런트 React도 만들게 되었습니다.</p>\n<p>이때 얻은 교훈은 한 두 가지가 아닙니다. 프로젝트를 만들어보는 건 학습의 밀도가 달랐습니다. 1주일에 책을 2권씩 봤습니다. 하지만 책에 없는 게 더 많았죠. 공식 문서를 찾아보면서 삽질하고 삽질했습니다.</p>\n<p>한편으로는 웹 개발에 자신감이 생겼고, 데이터 분석 말고 웹 개발 쪽으로 가보는 건 어떨지 고민하기 시작했습니다.</p>\n<p>프로젝트를 끝날 때 즈음에 저는 절박함을 느꼈습니다. 제가 군대에서 한 막코딩으로는 한계가 있었습니다. 타입 변환을 까먹거나, 오타 하나로 몇 시간을 허비하는 삶은 싫었습니다. 팀원의 부족함을 탓하며 혼자서 모든 걸 떠앉기도 싫었습니다.</p>\n<h2 id=\"테스트-주도-개발과-설계\">테스트 주도 개발과 설계</h2>\n<p>막연히 테스트가 이 문제들을 해결해주지 않을까 싶었습니다. 그때 읽은 [테스트 주도 개발], [리팩토링]이 참 많은 걸 줬습니다. 코드를 단순하게 리팩토링하고 테스트를 만들면서, 몇 시간 씩 고민하는 일이 급격히 줄었습니다. 확신을 가지고 더 많은 책을 사서 읽고, 문서도 읽어보면서 이것저것 해봤습니다. [클린 소프트웨어], [그림으로 배우는 HTTP 네트워크], [객체지향의 사실과 오해], [오브젝트], [이펙티브 자바], [스프링 부트와 AWS로 직접 만드는 웹 서비스] 등등... 읽기만 하고 실습은 나중으로 미뤄둔 [자바 웹 넥스트 스텝], [토비의 스프링], [스프링 인 액션] 같은 친구들도 있네요.</p>\n<h2 id=\"삶을-풍요롭게-하는-코칭\">삶을 풍요롭게 하는 코칭</h2>\n<p>이때 쯤에 코칭도 시작했습니다. 처음에는 영어 과외를 했는데요. 그러다 데이터 과학 코칭을 시작했고, 결국 프로그래밍 코칭까지 갔습니다. 중,고등학생, 대학생, 대학원생, 회사원, 주니어 프로그래머 참 많은 분들을 만나서, 같이 고민하고 코딩했습니다. 그 중에는 국비를 다니시거나, 멋쟁이 사자처럼, 노마드 코더 같은 기존에 다른 강의나 부트캠프를 하고 계신 분도 많았습니다. 통계, 머신러닝, 딥러닝, 사무자동화, 백엔드, 프런트, 앱까지 참 이것저것 잡다하게 했습니다.</p>\n<p>제가 벤치마크하고 싶은 건 김창준님의 AC2인데요. 제 코칭은 피코치의 참여를 유도하거나, 생성적으로 진행하는 등... 여러 측면에서 부족한 게 더 많다고 느낍니다.</p>\n<h2 id=\"첫-회사에서-인턴-스타트업의-현실에-좌절하다\">첫 회사에서 인턴, 스타트업의 현실에 좌절하다.</h2>\n<p>이런저런 사정으로 아버지의 집에서 쫒겨나, 어머니와 함께 살게 되었습니다. 학교를 휴학하고, 취직하려 데브매칭을 보거나 이력서를 넣기 시작했는데요. 결과는 썩 만족스럽지 않았습니다. 프로그래머스 레벨3까지 문제를 모두 풀었더니, 코테는 만점이었지만... 데이터 분석가로 지원한 회사 중에 단 한 곳도 면접조차 가지 못했습니다.</p>\n<p>그러다 장고 Rest 프레임워크, 리액트, 딥러닝 스택을 가진 한 스타트업 인턴 모집 공고를 보게 됐습니다. 신입 정규직은 어려워도 인턴은 되지 않을까? 그 회사가 제 첫 회사인 S사였는데요. 면접을 보러간 자리에서 바로 합격하고, 다음 날 바로 출근하게 됐습니다. \"이 정도 능력이면 신입으로 가도 될 것 같은데, 왜 인턴으로 지원하셨냐?\"는 말이 기억에 남네요. (아무도 저 같은 신입은 받아주지 않아서요!)</p>\n<p>S사에 있는 1달 동안 정말 많은 걸 했습니다. 배우고 시도했던 걸 적어보겠습니다.</p>\n<p>처음 한 일이 WSL에 Cython 딥러닝 모델을 서빙하는 장고 + 리액트 개발환경을 구축하는 거였습니다. Docker를 쓰고 있는데도, 그냥 도커 run으로 돌아가질 않았습니다. DB는 실 DB에 연결되어 있어서 테스트 DB로 바꿨고, requirements.txt 버전은 안 맞았고, Cython은 특이한 커스텀 툴체인을 쓰는데 문서가 없어서... 여튼 에러 메세지 보면서 2시간 정도 만에 개발환경을 구축했습니다.</p>\n<p>제가 처음 고친 기능이 줌인 줌 아웃이었습니다. 수동으로 사이트에 접속해서, 로그인하고, 사진을 업로드하고, 줌인 줌아웃을 하는 식으로 테스트를 했습니다. 상태 관리는 redux를 쓰는데, 너무 번잡해서 한 번 실험을 해보고 싶으시다며 prop 내리기가 되어 있었습니다. 뷰에서 상태를 바꾸는 로직이 이런저런 컴포넌트에 흩어져 있었습니다.</p>\n<p>처음에 시연하면서 보여주시는데 에러가 났습니다. 눈 앞에서 에러 메세지를 보고, 코드를 수정하고, 다시 서버가 갱신되면, 다시 접속해서, 로그인하고... 뭐 그래도 원인을 찾지 못했죠. 며칠 후에 투자자 분이 사이트에서 직접 해보시는데 안 된다고 하시니, \"아직 프로토타입이고 상관 없다.\"고 말씀하셨던 게 기억이 납니다.</p>\n<p>저는 뷰에서 상태를 끌어내고 싶었습니다. Redux가 싫으시다니, MobX라는 게 있다고 알려드리고 원리를 설명했습니다. MobX 괜찮은 것 같다. 한 번 이사를 가보자. 사실 레거시가 대학생 프로젝트처럼 조그만해서 전환에 부담도 없었습니다.</p>\n<p>Cypress로 앞서 말한 End to End 테스트를 자동화했습니다. 이미지 파일 업로드, 마우스 스크롤을 어떻게 하는지 몰라서 헤맸던 기억이 납니다.</p>\n<p>그 다음에는 create-react-app에 내장된 jest로 상태 함수만 모아놓고 유닛 테스트를 했습니다. 상태 로직을 정확하게 구현했다는 확신을 얻고, 이제 기존 코드를 리팩토링 했습니다.</p>\n<p>이때 Mobile과 Desktop 뷰 컴포넌트가 따로 있었는데요. 설정 메뉴 모양만 다른데, 똑같은 상태 로직이 복사 붙여넣기 되어 있더군요. 이 공통 부분을 들어내고 통합했습니다. 그러니 복잡해서 전혀 다르게 보였던 Zoomable Image 컴포넌트가 사실은 동일하다는 걸 알게 됐습니다. 생각해보면 모바일이라고 PC와 다른 기능을 하지 않으니 당연했습니다. 공통 부분을 추출해서 Zoomable Image로 만들고, 프롭 내리기도 없애버렸습니다.</p>\n<p>이걸 가져갔더니 반응이 좋지 않았습니다. 모바일이랑 데스크탑의 기능이 달라질 수도 있는데, 지금 이렇게 추상화해놓으면 나중에 쓰기 불편해질 수도 있다는 것이었죠. 그렇게 생각할 수도 있죠.</p>\n<p>그 후로 계속 뭔가 잘못됐다는 느낌을 받았습니다. Github Issue조차 없어서 매번 구두로 전달 받아야했고요. 백엔드 API 문서가 있는지 물었는데, 역시 없었습니다. 장고 REST에서 자동으로 swagger open API를 만들어주는 툴 정도라도 있었으면 좋았을텐데요.</p>\n<p>하루는 \"지금 하고 있는 건 언제 끝나냐?\"는 질문을 받고, \"어디까지 해서 보여드리면 되겠습니까?\"하고 물었는데요. 그때 지시사항은 \"전에 말할대로 한 번 고쳐봐라.\"였습니다. 지시가 모호해서 질문을 한 건데 \"그런 건 스스로 생각해야한다.\"던가 \"책임감이 없다.\"는 식의 답변을 들었습니다. 그래서 \"제가 적어둔 작업 목록을 보여드릴테니, 그 중에 뭘 할지 골라주시면 시간을 추정하기 쉬울 것 같다.\"고 말씀을 드렸는데요. \"아까 전에는 그렇게 말 안 하지 않았냐?\"는 답이 돌아왔죠.</p>\n<p>물론 이런 업무 절차가 미비할 수 있습니다. 하지만 개선에 대한 의견을 받아들이지 않는 건 다른 문제죠. 이 이야기를 드리니 \"나는 대표인데 왜 신입인 너에게 맞춰야 하냐.\"는 답을 들었습니다. 그 외에 명대사로 \"왜 나에게 설명하듯이 말하느냐.\" \"내가 얼마나 많은 프로젝트를 만들었는지 아느냐?\" \"내가 풀스택 6년차인데\" 등이 있습니다.</p>\n<p>결국 1달만에 그만두기로 했습니다. 나오면서 제가 했던 작업들과, 프로젝트 구조와 방향, 환경 설정 방법을 정리한 문서를 만들어 남겼습니다.</p>\n<p>\"1년은 버텨봐야하는 거 아니냐\" \"요즘 애들은 근성이 없다.\"고 생각하시는 분이 있다면, 별로 드릴 말씀은 없네요. 환경을 무시하고 사람의 성격을 판단할 수 있다는 심리학적 통찰력에 박수를 보내드립니다. ;)</p>\n<h2 id=\"프메-백업-뷰어를-만들다\">프메 백업 뷰어를 만들다.</h2>\n<p>첫 회사를 그만두고 고민이 많았습니다. 때로는 먼저 연락이 오기도 하고, 제가 지원서를 넣기도 했는데. 1차에서 떨어진 경우도 많았고, 면접에서 떨어지기도 했습니다.</p>\n<p>면접에서 떨어져도 보통 정중하게 복사 붙여넣기한 인사만 받기 때문에, 왜 떨어졌는지는 알 수 없었습니다. 내가 비전공자라서 그럴까? Python Django는 역시 너무 마이너한 게 아닐까? 저에 대한 의심만 커졌죠. 임상 심리사님과 상담을 하면서 이런 불확실성을 어떻게 받아들여야할지?... 고민했고, 지금도 고민하고 있습니다.</p>\n<p>그러다 연습이 아닌 새로운 프로젝트 [프메 백업 뷰어]를 시작하게 되었습니다.</p>\n<p>저는 아이돌 그룹 아이즈원의 팬인데요. 아이즈원 팬덤은 충격과 슬픔에 빠졌습니다. 할 수 있는 건 없고 무력감만 남았죠.</p>\n<p>요즘 아이돌은 프라이빗 메일, 혹은 버블이라는 서비스가 있습니다. 아이돌 멤버들이 팬들과 메세지를 공유하는 팬 전용 SNS 같은 느낌인데요. 아이즈원이 활동을 종료하면서 아이즈원 프라이빗 메일도 서비스를 종료하게 되었습니다. 앱 이용약관은 \"자기 책임 하에 백업할 것\"을 요구했는데요. 팬들은 8천 장이 넘는 메일을 스크린샷을 찍어서 하나하나 백업하고 있었습니다.</p>\n<p>이때 한 개발자가 서버 REST API에 요청을 보내서 1시간에 걸쳐 8천 장의 메일을 불러와 저장하는, 이른바 프메 백업 툴을 만들었습니다. 저도 이 툴로 백업을 했는데. 받고 보니 문제가 있었습니다.</p>\n<p>메일 백업은 HTML과 이미지, 그리고 메일 목록과 정보가 담긴 json 파일로 이루어져 있습니다. JQuery로 만든 간단한 뷰어가 있긴 했지만, 볼 수 있는 걸 제외하면 아무 기능도 없었습니다.</p>\n<p>저는 마침 관심을 두고 있던 FastAPI, Svelte와 tailwind를 가지고 다양한 기능을 갖춘 뷰어를 만들면 어떨까 싶었습니다.</p>\n<p>그렇게 프메 백업 뷰어 프로젝트를 시작해서, 팬들과 지속적으로 공유했습니다. 처음에는 설치조차 불편했지만 스크립트를 만들어 자동화했고요. 다양한 기능을 추가해나갔습니다</p>\n<ul>\n<li>날짜 달력</li>\n<li>파파고 번역</li>\n<li>검색</li>\n<li>태그</li>\n<li>서버를 이용한 데이터 동기화</li>\n<li>좋아요</li>\n<li>다크모드</li>\n<li>프로필 사진 바꾸기, 직접 업로드하기</li>\n<li>영상 스트리밍</li>\n<li>N 년전 오늘</li>\n<li>앨범</li>\n<li>사진 크게 보기</li>\n<li>비동기 메일 백업</li>\n</ul>\n<p>팬들의 반응과 의견은 큰 힘이 되었습니다.</p>\n<p>한편으로는 에러가 두려웠습니다. ;) 사용자는 정말 다양한 방법으로 실수를 할 수 있습니다. 사용자의 실수를 예측하고, 에러가 나더라도 적절하게 대처할 수 있게 만들어야 했습니다. 윈도우와 안드로이드만 사용해온 저에게, 맥과 사파리에서 일어나는 크로스 플랫폼, 크로스 브라우징 이슈를 해결해나가는 것도 새로웠습니다.</p>\n<p>백엔드에서는 당연하게 생각했던 여러 설계 원칙을, 프런트 엔드에도 적용하게 됐습니다. End to End 테스트는 확실하지만 너무 느립니다. 테스트를 피하게 되고 코드가 꼬이게 됩니다. 하지만 테스트 없이 View와 State가 뒤섞인 코드는 재사용하기 어렵고, 리팩토링하기 고통스럽죠.\n도메인-상태의 로직으로 더 끌어내서, 의존성 없이 Jest만으로 테스트할 수 있게 만드니... 많은 문제가 저절로 풀렸습니다.</p>\n<p>이 외에도 배운 건 많지만 다음 이야기로 넘어가죠.</p>\n<h2 id=\"내가-가치-있게-생각하는-일을-해나가자\">내가 가치 있게 생각하는 일을 해나가자.</h2>\n<p>마지막은 감성적인 이야기입니다. 저는 최근에 삶의 방향을 잡았습니다.</p>\n<blockquote>\n<p>최근에 삶의 방향을 정했는데. 생계도 안정적이니 소수자이지만 유망한 기술을 더 쉽고 정확하게 배울 수 있게 하는 일에 헌신해볼 생각이다.</p>\n<p>FastAPI, Svelte, Scala, Clojure, Elixir, 그래프 데이터베이스 등을 진흥시키기 위해서. 자료를 정리하고, 깊이 있는 튜토리얼을 열심히 만들 겁니다.</p>\n</blockquote>\n<p>제 삶에 즐거움, 가치는 크게 2가지가 있다고 생각합니다. 하나는 문제를 풀고 해결하고 알아가는 즐거움이고, 다른 하나는 사람들과 함께 하면서 도움이 되고 있다는 느낌입니다.</p>\n<p>첫 번째 즐거움을 느끼는 분이 얼마나 되실지 모르겠습니다. 수학이나 물리, 프로그래밍이 재미있다고 느끼는 사람은 괴짜가 아닐까요. ;) 일이나 공부, 성공 같은 '기준'에 맞춰서 힘들고 '해야하는 것'으로 여겨지기 쉽습니다. 저도 그런 압박감을 느끼곤 합니다.</p>\n<p>두 번째는 좀 특별합니다. 이건 단순히 나 혼자 방에 틀어박혀서 공부만 해서는 얻기 힘드니까요. 잘못 흐르면 관심에 집착하거나, 공허해질 수 있지만. 사람은 원래 사회적인 동물입니다. 행복에 대한 연구들은 인간 관계가 행복에 가장 중요한 요소 중에 하나라고 이야기하고 있죠. 당장 가족, 친구, 직장, 취미, 사랑까지 넘쳐나는 관계들을 생각해보세요! 서로 도움을 주고 받고 감사하는 관계가 많다면 더욱 즐거울 수 밖에 없을 겁니다.</p>\n<p>저는 여러모로 운이 좋았다고 생각합니다. 중학교 때 저의 친구가 되어주셨던 사서 안미주 선생님과, 고등학교 때 마찬가지로 도와주셨던 정윤지예 선생님. 역시 은인이신 장영두 선생님... 여러 은인 분들 덕분에 죽고 싶을 때 죽지 않았고요. 책을 좋아하게 되었고, 영어를 포기하지 않았습니다.</p>\n<p>저는 학습과학과 전문성에 관심을 가지고 많은 걸 배웠습니다. 학습원리들을 프로그래밍에 적용하면서, 빠르게 배우고 성장할 수 있었다고 생각합니다. 물리학과인 제가 컴퓨터 공학과 학부생 분들을 코칭하고 있으니까요.</p>\n<p>프로그래밍 코칭을 하면서 생계에도 큰 걱정 없이 살고 있습니다. 제가 생계가 곤란하고 힘들었다면, 취업에 더 집착하고 두려워할 수 밖에 없었을 겁니다. 전에 배민 커넥트 배달을 했었는데, 시간 당 1만원 정도 꽤 벌었지만 정말 힘들었습니다. 프로그래밍 코칭은 돈도 더 많이 벌고, 제가 더 좋아하고 즐기는 일이기도 합니다. 제가 하루 8시간씩 코칭을 하진 않아서, 수익이 많진 않지만. 저는 원래 검소하고, 밥도 직접 해먹기 때문에 괜찮은 것 같네요.</p>\n<p>저 역시 제가 아직 모르는 게 많고, 부족하다는 걸 압니다. 하지만 지금까지 그래왔듯이, 앞으로도 성장해나갈 것임을 믿습니다. 생태계를 위해 기여하고, 가치를 전해보고 싶습니다.</p>\n<p>프메 백업 뷰어에서 그랬던 것처럼, 제가 관심을 가지고 공부 중인 기술과, 함수형, TDD, 애자일 같은 방법론을 더 퍼트리고 싶습니다.</p>","data":{"tocTree":[]},"permanlink":"/my-programming-story/","tags":["초고","이야기"]},{"slug":"string-escape","frontmatter":{"title":"문자열 escape, format, injection attack","excerpt":"SQL이나 HTML, JSON도 모두 문자열이죠. 코드를 문자열로 만들 때의 편리함과 취약점에 대해 알아봅니다.","date":"2021-07-17T12:38:53.894790","author":"탐정토끼(Taehee Kim)","tag":"작성 중, 문자열, escape, format, injection attack"},"html":"<h3 id=\"escape-이건-코드인가-문자열인가\">Escape: 이건 코드인가 문자열인가?</h3>\n<p>문자열 리터럴을 만들 때 머리 아픈 부분은... 엔터나 따옴표 같은 특수문자를 어떻게 처리하냐는 것입니다.</p>\n<h3 id=\"format-문자열-템플릿에-동적으로-데이터-넣기\">format: 문자열 템플릿에 동적으로 데이터 넣기</h3>\n<h3 id=\"자동-형변환-다른-타입을-문자열로-변환하기\">자동 형변환: 다른 타입을 문자열로 변환하기</h3>\n<h3 id=\"injection-공격--eval과-sql-injection\">Injection 공격 : eval과 SQL Injection</h3>\n<h3 id=\"인덱스가-0부터-시작하는가\">인덱스가 0부터 시작하는가?</h3>\n<p>포트란, Lua, Julia</p>\n<h3 id=\"인덱스-슬라이싱이-가능한가\">인덱스 슬라이싱이 가능한가?</h3>\n<h3 id=\"인덱스-for-vs-iterator\">인덱스 for vs Iterator</h3>\n<h3 id=\"정규표현식\">정규표현식</h3>","data":{"tocTree":[]},"permanlink":"/string-escape/","tags":["작성 중","문자열","escape","format","injection attack"]},{"slug":"string-immutable","frontmatter":{"title":"문자열은 왜 불변인가?","excerpt":"많은 언어에서 문자열은 불변입니다. 불변 자료형은 단점도 있고, 함수형 언어에서나 많이 쓰이는데. 문자열은 어쩌다 불변 객체가 표준이 되었을까요?","date":"2021-07-16T18:32:59.350932","author":"탐정토끼(Taehee Kim)","tag":"작성 중, 문자열, 불변, 함수형"},"html":"<h3 id=\"문자열은-보통-불변입니다\">문자열은 보통 불변입니다.</h3>\n<p>대부분의 언어에서 문자열은 불변(Immutable)입니다. 변하지 않는다고 하면 이해하기 어려워하는 사람들이 있을텐데. 정확하게 말하면 문자열을 수정할 때, 새로운 문자열을 복사해서 만든다는 이야기다. 이걸 Copy on Write 라고도 한다. 파이썬에서 가변(mutable)한 자료형인 List와 비교해서 알아보자.</p>\n<pre><code class=\"language-python\"># 문자열\na = \"hello\"\n# 문자 List. 타입은 사실 List[str] 이지만...\nb = ['h', 'e', 'l', 'l', 'o']\n\n# 값을 복사한다.\na_copy = a\n# 레퍼런스를 복사한다.\nb_copy = b\n\n# \", world\"를 뒤에 붙인다.\na_copy += \", world\"\n# 마찬가지. 이번에는 겹 따옴표를 써봤다.\nb_copy += [\",\", \" \", \"w\", \"o\", \"r\", \"l\", \"d\"]\n\nprint(a)\n# \"hello\" 원본은 그대로\nprint(a_copy)\n# \"hello, world\" 복사본은 수정됐다.\n\nprint(b)\n# ['h','e','l','l','o',',',' ','w','o','r','l','d'] 원본도 같이 변했다!!!\nprint(b_copy)\n# ['h','e','l','l','o',',',' ','w','o','r','l','d'] \n</code></pre>\n<p>변수는 메모리에 특정한 위치를 가리키는 레퍼런스를 들고 있다. 그런데 불변인 값은 메모리의 내용을 수정할 수 없다. 그래서 값을 수정하면 메모리에 새로운 위치에 값을 복사해서 쓰고, 변수에 새로운 위치를 가리키는 레퍼런스를 넣어놓는다. a_copy를 수정해도 a는 예전 위치를 가리키고 있기 때문에, 아무런 영향이 없다.</p>\n<p>반면에 리스트는 메모리의 값을 수정할 수 있어서, 항상 같은 위치를 가리키고 있다. 그러니 복사한 다른 변수가 값을 수정하면 원본도 바뀌는 것입니다.</p>\n<h3 id=\"불변성의-성능-이슈\">불변성의 성능 이슈.</h3>\n<p>사실 불변 자료형은 함수형 프로그래밍에서는 많이 쓰지만, 다른 언어에는 흔하지 않습니다. 파이썬에서도 List는 가변입니다.</p>\n<p>불변 자료형은 매번 값을 새로 쓰기 때문에 성능에 불리한 면이 있었습니다. 내가 책을 하나 새로 샀다고 합시다. 가변 책장이라면 책을 새로 꽂으면 끝납니다. 하지만 불변 책장에서는 책장을 새로 만들어서 기존에 있던 책들을 모두 옮겨야 합니다...</p>\n<p>실제로 매우 많은 문자열을 합칠 때, 이 문제는 심각한 고민입니다. Python에서 문자열을 합칠 때 앞에서 본 + 연산자를 쓸 수 있습니다. 한 두 개는 이래도 괜찮지만, 문자열 수백 수천 개를 합칠 때에는 같은 문자열을 지우고 만들기를 수백 수천 번 반복하니 비효율적일 수 밖에 없습니다.</p>\n<p>그래서 Python에서는 이렇게 많은 문자열을 합칠 때에는 join을 쓰기를 권장합니다. join은 미리 모든 문자열을 합칠 수 있는 공간을 만들어두고, 한 번에 새 문자열을 만들기 때문에 빠릅니다. JS도 비슷하게 for이나 reduce보다 join을 사용하라 합니다. Java에서는 StringBuilder나 StringBuffer를 추천합니다.</p>\n<pre><code class=\"language-python\">very_large_data_list = [\"장원영\", \"홍다희\", \"나북희\", ..., \"김민주\"]\n\nresult_1 = \"\"\nfor name in very_large_data_list:\n    # 합쳐서 새 문자열을 만든다.\n    line = name + \"\\\n\"\n    # result를 지우고 새 문자열을 또 만든다.\n    result_1 += line\n\n# 한 번에 모든 문자열을 합친다.\nresult_2 = \"\\\n\".join(very_large_data_list)\n\n</code></pre>\n<p>하지만 애초에 String이 가변이었다면 이런 고민은 하지 않아도 됩니다. 그러면 왜 불변성을 유지하는 걸까요?</p>\n<h3 id=\"불변-자료구조는-해싱-캐싱할-수-있고-안전하다\">불변 자료구조는 해싱, 캐싱할 수 있고, 안전하다.</h3>\n<p>앞서 말했듯이 함수형 프로그래밍에서는 적극적으로 불변 자료구조를 쓴다. 심지어 Clojure나 Elixir 같은 언어에서는 기본적으로 불변 Linked List를 사용한다. (대부분 주류 언어에서는 ArrayList를 쓴다.) 흔히 함수형의 장점이라 알려진 것들이 불변성의 장점인 경우가 많다.</p>\n<p>먼저 불변 값은 쉽게 Hash key로 쓸 수 있다. 문자열은 보통 HashMap이나 dict, HashSet 등등에서, key로 많이 쓰인다. 특히 js의 객체는 모두 HashTable로 되어 있다. 문자열이 가변이라면 매번 hash 값이 변할 수 있어서 믿을 수 없을 것입니다. 하지만 불변하는 값은 hash를 한 번 계산해두면 변할 일이 없어서 안심할 수 있다.</p>\n<p>그래서 불변 자료구조는 캐싱으로 재사용하기 쉽다. 똑같은 값을 가진 새로운 데이터를 만들 때, 메모리에 새로 공간을 만들 필요가 없다. 원래 있던 변수 중에 똑같은 값을 찾아서 메모리에 똑같은 위치를 가리키는 레퍼런스만 달아주면 끝입니다. 예를 들어 \"Hello, World\" 라는 문자열 1천 개를 만든다면 가변 자료구조는 1천 개의 공간이 필요하지만, 불변 자료구조는 원본 하나 저장할 공간만 있으면 된다. 앞서 말한 hash함수를 이용하면 O(1) 만에 값을 찾을 수 있으니 성능 상으로도 유리하다.</p>\n<p>또 멀티 쓰레드나 동시성을 쉽게 다룰 수 있다. 요즘처럼 멀티코어가 당연해지는 세상에서는 정말 중요한 성질입니다. 가변 상태는 디버깅하기 매우 귀찮기 때문입니다.</p>\n<p>이런 이유로 파이썬에서는 str 뿐만 아니라 int, float, bool, tuple 같은 많은 기본 데이터 타입을 모두 불변 객체로 쓰고 있다.</p>\n<p>이유는 이 밖에도 더 있겠지만. 일단 \"불변이 생각보다 나쁘지 않구나, 함수형 언어도 좀 배워봐야겠다\"는 정도만 알고 넘어가자.</p>","data":{"tocTree":[]},"permanlink":"/string-immutable/","tags":["작성 중","문자열","불변","함수형"]},{"slug":"string-encoding","frontmatter":{"title":"문자, 문자열, 한글 인코딩","excerpt":"한글을 어떻게 컴퓨터에 0101로 저장할 수 있을까요? UTF-8 이 있기까지 인코딩의 역사에 대해 이야기합니다.","date":"2021-07-16T18:22:02.346816","author":"탐정토끼(Taehee Kim)","tag":"작성 중, std, 문자열, 인코딩, 한글, 유니코드, UTF-8"},"html":"<h2 id=\"char-array와-string을-구분하는가\">Char Array와 String을 구분하는가?</h2>\n<p>문자열은 원래 문자(Char) 배열(Array)이었습니다. 예를 들어 \"tae\" 는 문자열인데 't', 'a', 'e' 라는 3가지 문자로 이루어져 있죠.</p>\n<p>char는 C나 Java 같이 저수준을 다루는 고급 언어에서 문자를 나타내는 원시(primitive) 자료형입니다. 영어로 문자를 뜻하는 character의 줄임말입니다. 이런 언어에서는 보통 char 리터럴은 <code>'s'</code> 같이 홑 따옴표(single quote)로 감싸줍니다. 변수명과 헷갈리기도 하고 1은 int 정수 자료형이지만 '1'은 문자이기 때문입니다.</p>\n<p>특히 C 같은 언어에서는 문자열이 정말 char의 배열일 뿐이죠.</p>\n<pre><code class=\"language-c\">char hello[5] = {'H', 'e', 'l', 'l', 'o'}\n</code></pre>\n<p>문자열을 단지 포인터를 이용해 사용하기도 하는데. 포인터는 배열의 첫 번째 글자를 가리키게 합니다. 문제는 문자열의 길이를 모른다는 것인데, 그래서 문자열 끝에는 \\\\0 null 문자를 붙여서 \"끝났습니다.\"하고 표시해준다는 규칙이 있습니다.</p>\n<p><code>[ H | e | l | l | o | \\\\0 ]</code></p>\n<p>이걸 실제 이진수로 변환하면 이렇겠죠.</p>\n<p><code>[ 1001000 | 1100101 | 1101100 | 1101100 | 1101111 ]</code></p>\n<p>C를 사용해본 적이 없으면 이해가 잘 가지 않을텐데. 이렇듯 단순히 문자 배열로 취급하면 여러모로 귀찮을 수 밖에 없습니다! 저수준에서 메모리에 데이터가 어떻게 저장되고, 어떻게 불러오는지 매번 신경 써야 한다니.</p>\n<h3 id=\"문자열-string은-보통-불변-객체다\">문자열 String은 보통 불변 객체다.</h3>\n<p>반면 요즘 대부분의 언어에서는 String을 불변 객체로 포장해서 사용합니다. C++에도 std::string이 있죠. 이런 객체들은 보통 특정 메모리 내의 위치를 가리키는 포인터가 아니라, 레퍼런스를 들고 있습니다. 그래서 값을 바꾸면 자동으로 새로운 위치를 찾아서 값을 저장하고, 레퍼런스를 바꿔치기합니다. 이러한 불변성에 대해서는 <a href=\"/string-immutable\">문자열은 왜 불변 객체일까?</a>에서 다룹니다.</p>\n<p>문자열 리터럴을 만들기 위해서는 보통 <code>\"Hello\"</code>처럼 겹따옴표로 감싸줍니다.</p>\n<p>그런데 python 이나 javascript 같은 언어에서는 한 글자도 string 으로 취급합니다. 이런 언어에서는 문자열을 만들 때 <code>\"</code> 던 <code>'</code>던 원하는 쪽을 마음대로 쓰면 됩니다. 그래서 다음과 같은 코드가 가능하죠.</p>\n<pre><code class=\"language-javascript\">const h_1 = 'H';\nconst h_2 = \"H\";\n\nconst hello_1 = \"Hello\";\nconst hello_2 = 'Hello';\n</code></pre>\n<p>js에서는 보통 ' 홑 따옴표를 많이 쓰는데. html 같은 문자열 안에 \"\"가 들어 있어도 따로 이스케이프해줄 필요가 없기 때문입니다.</p>\n<h3 id=\"문자열-인코딩은-문자를-0101-이진수에-대응시키는-방식\">문자열 인코딩은 문자를 0101 이진수에 대응시키는 방식</h3>\n<p>컴퓨터에 모든 데이터는 01010011 이진수 바이트로 저장합니다. int는 좀 이해하기 쉽지만, float이나 다른 자료구조가 저장되는 방식은 머리가 아픕니다. 특히 언어를 막론하고 가장 많이 쓰이는 String은 생각보다 만만치 않은 자료형(data type)입니다.</p>\n<p>컴퓨터는 자료형의 규칙에 따라 0101 을 해석하는데. 앞에서 문자열은 문자의 배열이라고 했었죠? 그러니 문자를 표기하는 방법이 필요한데. 요즘 가장 많이 쓰이는 표준은 유니코드, UTF-8입니다.</p>\n<p>유니코드는 기본적으로 문자표라고 생각합시다. 유니코드 문자표는 각 문자를 숫자에 대응시킵니다.</p>\n<p>예를들어 \"123Hello세계\"라는 문자열을 유니코드로 표현하면 <code>49, 50, 51, 72, 101, 108, 108, 111, 49464, 44228</code> 가 됩니다.</p>\n<pre><code>49 -> '1'\n72 -> 'H'\n'세' -> '49464'\n</code></pre>\n<p>같은 식으로 대응되는 것입니다.</p>\n<p>당연하지만 세상에는 다양한 문자표가 있고, 어떤 문자표를 쓸지 고민하게 됩니다. 이걸 보통 인코딩(Encoding)이라 부르는데. 문자를 코드로 어떻게 적을지에 대한 규칙입니다.</p>\n<h3 id=\"ascii--american-standard-code-for-information-interchange\">ASCII : American Standard Code for Information Interchange</h3>\n<p>태초에는 ASCII 문자표라는 걸 많이 썼습니다. 아스키의 장점은 미국 사람들이 쓰는 알파벳만 넣어서, 총 문자는 128개 이하, 즉 7비트 밖에 안 되는 가벼운 친구였다는 거죠. 하지만 미국인용 정보 교환 표준 코드(American Standard Code for Information Interchange)라는 이름처럼, 아스키로는 한글이나 다른 문자를 적을 방법이 없었습니다.</p>\n<p>그래서 사용자 이름을 한글로 짓거나, 폴더 이름을 한글로 하면 프로그램이 깨지는 경우가 아직도 종종 있습니다. 프로그램이 아스키는 읽는데 한글은 못 읽기 때문입니다.</p>\n<h3 id=\"다양한-언어들의-인코딩-난립\">다양한 언어들의 인코딩 난립</h3>\n<p>이게 싫었던 CJK(China Japan Korea)를 비롯해 여러 나라 사람들이 자기 나라별로 표준을 만들기 시작했는데. 지금 수 많은 충전기 양식이 난립하듯이, 이게 개발자들에게는 정말 고통스러웠습니다. 다른 코덱을 쓰는 프로그램에 데이터를 보내면 매번 인코딩을 변환해야했으니까요. 까먹고 변환을 안 해서 에러와 장애가 일어나고, 사이트를 들어갔는데 보이지 않는 일도 흔했다고 합니다.</p>\n<p>한글만해도 EUC-KR, CP949 같은 친구들을 이따금 보게 될 것입니다.</p>\n<h3 id=\"세계-표준-유니코드-등장\">세계 표준 유니코드 등장</h3>\n<p>그래서 세계 표준을 만들자는 움직임이 있었고, 그렇게 나온 문자표가 유니코드입니다! 유니코드에는 중국 한자, 한글, 아랍어는 물론이고, 타밀어나, 티벳 문자까지 온갖 문자가 모두 들어 있습니다.</p>\n<p>유니코드 코드 포인트로 된 텍스트 파일을 열어보면 다음처럼 생겼습니다.</p>\n<p>원본은 <code>\"간장공장 이모지\"</code>입니다.</p>\n<pre><code class=\"language-plaintext\">\"\\\\uac04\\\\uc7a5\\\\uacf5\\\\uc7a5 \\\\uc774\\\\ubaa8\\\\uc9c0\"\n</code></pre>\n<p>문제는 이렇게 많은 문자표를 만들다보니 표가 너무 길어졌다는 건데. 앞에서 보셨듯이 한글은 49464 처럼 매우 크기가 크지 않나요? 그래서 1바이트로 처리되는 아스키와 달리, 한글은 최소 3바이트가 필요하고, 더 뒤에 있는 고문자나 이모티콘은 4바이트가 필요할 수도 있습니다.</p>\n<p>여기서 고민이 생기는데. 고정 길이 배열로 저장하는 게 속도는 빠르지만. 그러면 당연히 가장 긴 데이터에 맞출 수 밖에 없습니다. 영어로만 되어 있어서 1바이트면 되는 문자도, 한 글자에 4바이트씩 쓴다면... 용량이 4배로 늘어날 것입니다.</p>\n<h3 id=\"utf-8-메모리-효율적인-가변길이-유니코드-인코딩\">UTF-8 메모리 효율적인 가변길이 유니코드 인코딩</h3>\n<p>그래서 GO의 개발자이기도 한 켄 톰슨과 롭 파이크는 UTF-8을 만들었습니다. UTF-8은 Unicode Transformation format의 약자입니다. 즉 유니코드를 가변 길이로 변환해서 저장하는 포맷입니다. 영어는 1바이트만 쓰고, 한글 같이 복잡한 문자만 3바이트를 써서 저장하도록 했죠.</p>\n<p>요즘 대부분의 언어와 파일은 이제 UTF-8을 표준으로 택하고 있습니다. 예를들어 파이썬3나 js 같은 언어에서 코드와 문자열은 기본적으로 UTF-8 인코딩을 이용합니다. 그래서 한글로 변수나 함수명을 짓는 것도 가능하죠.</p>\n<p>UTF-8은 메모리는 덜 먹지만, 길이가 들쭉날쭉하기 때문에 성능 상으로는 불리한 면이 있습니다. 단순하게 문자열 길이를 셀 때를 생각해보세요. 고정 길이라면 메모리 길이와 같겠지만, 가변 길이에서는 정말 문자 개수를 하나하나 세야 합니다.</p>\n<p>또 한글은 여전히 고통스럽습니다. UTF-8은 영어만 1바이트거든요. 한글은 여전히 3바이트나 차지합니다. (EUC-KR은 2바이트 였습니다.) 이러나저러나 미국 중심의 표준입니다.</p>\n<blockquote>\n<p>사실 한글이 처리되는 방식은 더 복잡합니다. 예를들어 맥과 윈도우가 처리하는 방식이 다르다던가요. 한글을 자음과 모음 각각을 저장할 수도 있고, 완성형을 저장할 수도 있기 때문입니다. (\"ㄱㅣㅁ ㅌㅐ ㅎㅡㅣ\" vs \"김태희\") 더 궁금하신 분은 다음 링크를 살펴봐주세요.</p>\n<ul>\n<li><a href=\"https://gist.github.com/Pusnow/aa865fa21f9557fa58d691a8b79f8a6d\">한글과 유니코드</a>: 한글 정규화, 단위, 정렬 문제</li>\n<li>파이썬\n<ul>\n<li><a href=\"https://docs.python.org/ko/3.8/howto/unicode.html\">파이썬 공식 문서: 유니코드 HOWTO</a></li>\n<li><a href=\"https://www.youtube.com/watch?v=w-3oMfBjXCI\">한상곤: 문자열? 그런 달달한 것이 남아있긴 한가? - PyCon APAC 2016</a></li>\n<li><a href=\"https://www.python.org/dev/peps/pep-0393/\">PEP 393 -- Flexible String Representation</a></li>\n</ul>\n</li>\n</ul>\n</blockquote>\n<p>그래도 표준이 있는 게, 없는 것보다는 나은 것 같습니다. 해외 라이브러리도 UTF-8만 지원하면 쓸 수 있고요. 많은 언어들이 UTF-8을 채택하면서 한국어 쓰기가 점점 편해졌습니다. 불과 몇 년 전만 해도 인터넷 익스플로러는 EUC-KR(CP949)를 쓰고 있었습니다. 서버에서 보내준 한글 데이터가 다 깨지는 참사가 일어나기도 했죠.</p>\n<p>하지만 이제 익스플로러도 지원 종료되었으니... UTF-8의 미래는 밝습니다.</p>\n<p>여전히 파일이나 DB에 데이터를 저장할 때라던가, 통신으로 날아온 JSON을 읽어들일 때 우리는 Encoding을 신경 써야합니다. 한글이 깨지는 경우도 종종 있을 겁니다. 같은 유니코드라도 UTF-8 인코딩 말고 다른 친구도 있습니다. UTF-16이나 이모티콘, UCS-2 같은 복병이 숨어 있기도 합니다. 낯선 프로그래밍 언어를 쓰는데 글자가 깨진다면, 인코딩 설정을 한 번 의심해보시고, 검색어에 \"UTF-8\"이나 \"encoding\" 같은 단어를 넣어보세요.</p>\n<pre><code class=\"language-python\">import json\n\ndata = {\n  \"id\": 1,\n  \"name\": \"김태희\" # 한글\n}\n\n# 유니코드 코드 포인트 -> 아스키에 있는 문자로만!\njson_unicode_text = json.dumps(data)\n# '{\"id\": 1, \"name\": \"\\\\\\\\uae40\\\\\\\\ud0dc\\\\\\\\ud76c\"}'\n\n# UTF-8로 바로 변환되게 합니다.\njson_raw_utf_text = json.dumps(data, ensure_ascii=False)\n# '{\"id\": 1, \"name\": \"김태희\"}'\n\n# UTF-8 인코딩으로 텍스트 파일에 저장합니다.\nwith open(\"test.txt\", \"w\", encoding=\"UTF-8\") as f:\n    f.write(json_text)\n</code></pre>","data":{"tocTree":[]},"permanlink":"/string-encoding/","tags":["작성 중","std","문자열","인코딩","한글","유니코드","UTF-8"]},{"slug":"development-environment-15minutes","frontmatter":{"title":"개발환경 구축 지도","excerpt":"개발환경을 구축하는데 필요한 다양한 개념들을 정리하고, 큰 그림을 그립니다.","date":"2021-07-14T10:11:26.973689","author":"탐정토끼(Taehee Kim)","tag":"작성 중, 개발환경"},"html":"<h2 id=\"지도를-챙기고-필요한만큼-배우자\">지도를 챙기고, 필요한만큼 배우자</h2>\n<h2 id=\"내가-이해할-수-있고-감당할-수-있나\">내가 이해할 수 있고 감당할 수 있나?</h2>\n<h2 id=\"작고-단순한-것부터-시작하자\">작고 단순한 것부터 시작하자</h2>\n<h2 id=\"가설을-세우고-실험으로-검증하기\">가설을 세우고 실험으로 검증하기</h2>\n<h2 id=\"일반적이고-보편적인-개념을-배우자\">일반적이고 보편적인 개념을 배우자</h2>\n<h2 id=\"프로그램을-어디에서도-실행하게-해주는-환경변수-path\">프로그램을 어디에서도 실행하게 해주는 환경변수 PATH</h2>\n<h2 id=\"운영체제와-cpu에-맞는-프로그램-설치하기\">운영체제와 CPU에 맞는 프로그램 설치하기</h2>\n<h2 id=\"사용하는-버전-확인하기\">사용하는 버전 확인하기</h2>\n<p>Breaking Change</p>\n<h2 id=\"명령줄-command-line\">명령줄 Command Line</h2>\n<h2 id=\"컴파일러-인터프리터-런타임\">컴파일러, 인터프리터, 런타임</h2>\n<h3 id=\"gcc-리눅스-진영의-c-컴파일러\">GCC: 리눅스 진영의 C 컴파일러</h3>\n<h3 id=\"javac-자바-컴파일러\">javac: 자바 컴파일러</h3>\n<h3 id=\"cpython-파이썬-공식-인터프리터-구현체\">CPython: 파이썬 공식 인터프리터 구현체</h3>\n<h4 id=\"pypy\">PyPy</h4>\n<h3 id=\"node-js-런타임\">Node: js 런타임</h3>\n<h4 id=\"deno-rust로-다시-만든-jsts-런타임\">Deno: Rust로 다시 만든 Js/Ts 런타임</h4>\n<h3 id=\"babel-모던-자바스크립트를-위한-트랜스파일러\">Babel: 모던 자바스크립트를 위한 트랜스파일러</h3>\n<h3 id=\"tsc-타입스크립트-트랜스파일러\">TSC: 타입스크립트 트랜스파일러</h3>\n<h2 id=\"repl-console-명령줄에서-코드-실험하기\">Repl, Console: 명령줄에서 코드 실험하기</h2>\n<h3 id=\"python\">Python</h3>\n<h3 id=\"브라우저-개발자-도구-console\">브라우저 개발자 도구 Console</h3>\n<h2 id=\"빌드-패키지-의존성-관리-도구\">빌드, 패키지, 의존성 관리 도구</h2>\n<h3 id=\"gradle-java-패키지-관리-빌드-도구\">gradle: Java 패키지 관리, 빌드 도구</h3>\n<h3 id=\"npm-yarn-js-패키지-관리-도구\">npm, yarn: js 패키지 관리 도구</h3>\n<h3 id=\"webpack-rollup-vite-js-모듈-번들러\">webpack, rollup, vite: js 모듈 번들러</h3>\n<h3 id=\"pip-파이썬-기본-패키지-관리-도구\">pip: 파이썬 기본 패키지 관리 도구</h3>\n<h3 id=\"poetry-현대적인-파이썬-패키지-관리-도구\">poetry: 현대적인 파이썬 패키지 관리 도구</h3>\n<h3 id=\"apt-get-우분투-리눅스-패키지-관리-도구\">apt-get: 우분투 리눅스 패키지 관리 도구</h3>\n<h2 id=\"curl-wget-인터넷에서-파일-다운-받기\">curl, wget: 인터넷에서 파일 다운 받기</h2>\n<h2 id=\"sh-쉘-스크립트\">sh: 쉘 스크립트</h2>\n<h2 id=\"프로젝트-템플릿\">프로젝트 템플릿</h2>\n<h2 id=\"프레임워크-라이브러리-모듈\">프레임워크, 라이브러리, 모듈</h2>\n<h2 id=\"서로-다른-프로젝트-간에-버전-관리하기\">서로 다른 프로젝트 간에 버전 관리하기</h2>\n<h2 id=\"docker-개발환경을-컨테이너-째로-다운-받으세요\">Docker: 개발환경을 컨테이너 째로 다운 받으세요.</h2>\n<h2 id=\"각종-설정-config-파일\">각종 설정 config 파일</h2>\n<h2 id=\"텍스트-편집기\">텍스트 편집기</h2>\n<h3 id=\"vs-code-오픈소스-텍스트-에디터-플러그인-생태계\">VS Code: 오픈소스 텍스트 에디터, 플러그인 생태계</h3>\n<h3 id=\"jetbrain-똑똑한-통합-개발-환경\">JetBrain: 똑똑한 통합 개발 환경</h3>\n<h3 id=\"vim-강력한-단축키-커맨드-라인-최적화\">Vim: 강력한 단축키, 커맨드 라인 최적화</h3>\n<h3 id=\"그-외-emacs-sublime-text-notepad-메모장\">그 외: Emacs, Sublime Text, Notepad++, 메모장...</h3>\n<h2 id=\"문법-검사와-lsp\">문법 검사와 LSP</h2>\n<h2 id=\"git-프로젝트-버전-관리\">Git: 프로젝트 버전 관리</h2>\n<h2 id=\"배포-자동화\">배포 자동화</h2>\n<h3 id=\"github-action\">Github Action</h3>\n<h3 id=\"jenkins\">Jenkins</h3>\n<h2 id=\"브라우저-에뮬레이터\">브라우저, 에뮬레이터</h2>\n<h2 id=\"테스트-도구\">테스트 도구</h2>","data":{"tocTree":[]},"permanlink":"/development-environment-15minutes/","tags":["작성 중","개발환경"]},{"slug":"persistence-layer","frontmatter":{"title":"영속성 계층","excerpt":"영속성 계층은 프로그램의 상태와 데이터를 관리, 저장, 복원합니다. 파일부터 데이터베이스, DDD의 레포지토리 패턴도 소개합니다.","date":"2021-07-13T19:44:17.038983","author":"탐정토끼(Taehee Kim)","tag":"작성 중, DDD, 계층형 아키텍처, 영속성, 파일, 데이터베이스, 레포지토리 패턴"},"html":"<h2 id=\"영속성은-프로그램이-종료되어도-상태를-유지하고-다시-불러올-수-있게-합니다\">영속성은 프로그램이 종료되어도 상태를 유지하고, 다시 불러올 수 있게 합니다.</h2>\n<h2 id=\"파일-시스템\">파일 시스템</h2>\n<h2 id=\"데이터베이스\">데이터베이스</h2>\n<h3 id=\"sql-관계형-데이터-베이스\">SQL 관계형 데이터 베이스</h3>\n<h4 id=\"orm-객체-관계-맵핑\">ORM 객체 관계 맵핑</h4>\n<h4 id=\"두-개의-모자\">두 개의 모자</h4>\n<h3 id=\"nosql\">NoSQL</h3>\n<h4 id=\"key-value\">Key-Value</h4>\n<h4 id=\"document\">Document</h4>\n<h4 id=\"graph\">Graph</h4>\n<h4 id=\"search-engine\">Search Engine</h4>\n<h2 id=\"repository-pattern\">Repository Pattern</h2>","data":{"tocTree":[]},"permanlink":"/persistence-layer/","tags":["작성 중","DDD","계층형 아키텍처","영속성","파일","데이터베이스","레포지토리 패턴"]},{"slug":"api-layer","frontmatter":{"title":"API 계층","excerpt":"REST, gRPC, GraphQL, Socket, PubSub 등등... API 계층은 외부에서 들어온 요청을 작업으로 변환하고, 결과를 응답으로 변환하고 전달합니다.","date":"2021-07-13T18:30:36.653907","author":"탐정토끼(Taehee Kim)","tag":"작성 중, DDD, 계층형 아키텍처, API, REST, gRPC, GraphQL, WebSocket, PubSub"},"html":"<h2 id=\"api는-서버가-외부와-통신하는-방법이자-계약입니다\">API는 서버가 외부와 통신하는 방법이자, 계약입니다.</h2>\n<h2 id=\"수단과-양식-통신-프로토콜\">수단과 양식, 통신 프로토콜</h2>\n<h3 id=\"http-hypertext-transfer-protocol-하이퍼-텍스트-전송-규약\">HTTP: HyperText Transfer Protocol 하이퍼 텍스트 전송 규약</h3>\n<blockquote>\n<p>Hypertext Transfer Protocol (HTTP) is an application-layer protocol for transmitting hypermedia documents, such as HTML. It was designed for communication between web browsers and web servers, but it can also be used for other purposes. HTTP follows a classical client-server model, with a client opening a connection to make a request, then waiting until it receives a response. HTTP is a stateless protocol, meaning that the server does not keep any data (state) between two requests. Though often based on a TCP/IP layer, it can be used on any reliable transport layer, that is, a protocol that doesn't lose messages silently like UDP does. RUDP — the reliable update of UDP — is a suitable alternative.</p>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP\">MDN HTTP 문서</a></p>\n</blockquote>\n<blockquote>\n<p>The Hypertext Transfer Protocol (HTTP) is an application-level protocol for distributed, collaborative, hypermedia information systems. It is a generic, stateless, protocol which can be used for many tasks beyond its use for hypertext, such as name servers and distributed object management systems, through extension of its request methods, error codes and headers [47]. A feature of HTTP is the typing and negotiation of data representation, allowing systems to be built independently of the data being transferred.</p>\n<p><a href=\"https://datatracker.ietf.org/doc/html/rfc2616\">RFC2616 Hypertext Transfer Protocol -- HTTP/1.1 스펙</a></p>\n</blockquote>\n<h4 id=\"restful-representational-state-transfer-표현적-상태-전이\">RESTful: Representational state transfer 표현적 상태 전이</h4>\n<blockquote>\n<p>Client-Server, Stateless, Cache, Uniform Interface, Layered System</p>\n<p>Roy Thomas Fielding의 논문</p>\n<p><a href=\"https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm\">Architectural Styles and the Design of Network-based Software Architectures</a></p>\n</blockquote>\n<h4 id=\"openapi\">OpenAPI</h4>\n<blockquote>\n<p>The OpenAPI Specification (OAS) defines a standard, language-agnostic interface to RESTful APIs which allows both humans and computers to discover and understand the capabilities of the service without access to source code, documentation, or through network traffic inspection. When properly defined, a consumer can understand and interact with the remote service with a minimal amount of implementation logic.\nAn OpenAPI definition can then be used by documentation generation tools to display the API, code generation tools to generate servers and clients in various programming languages, testing tools, and many other use cases.</p>\n<p><a href=\"https://swagger.io/specification/\">Swagger 공식 사이트의 OpenAPI 소개</a></p>\n</blockquote>\n<h4 id=\"동사로-api만들기-rest를-넘어서\">동사로 API만들기: REST를 넘어서</h4>\n<h3 id=\"grpc-google-remote-procedure-call-구글-원격-프로시저-호출\">gRPC: google Remote Procedure Call 구글 원격 프로시저 호출</h3>\n<blockquote>\n<p>gRPC is a modern open source high performance Remote Procedure Call (RPC) framework that can run in any environment. It can efficiently connect services in and across data centers with pluggable support for load balancing, tracing, health checking and authentication. It is also applicable in last mile of distributed computing to connect devices, mobile applications and browsers to backend services.</p>\n<p><a href=\"https://grpc.io/about/\">About gRPC 공식 홈페이지</a></p>\n</blockquote>\n<h3 id=\"graphql-graph-query-language-진화하는-api를-위한-질의-언어\">GraphQL: Graph Query Language 진화하는 API를 위한 질의 언어</h3>\n<blockquote>\n<p>GraphQL is a query language for APIs and a runtime for fulfilling those queries with your existing data. GraphQL provides a complete and understandable description of the data in your API, gives clients the power to ask for exactly what they need and nothing more, makes it easier to evolve APIs over time, and enables powerful developer tools.</p>\n<p><a href=\"https://graphql.org/\">GraphQL 공식 사이트</a></p>\n</blockquote>\n<h3 id=\"websocket-양방향-실시간-이벤트-기반-통신을-위한-api\">WebSocket: 양방향, 실시간, 이벤트 기반 통신을 위한 API</h3>\n<blockquote>\n<p>The WebSocket API is an advanced technology that makes it possible to open a two-way interactive communication session between the user's browser and a server. With this API, you can send messages to a server and receive event-driven responses without having to poll the server for a reply.</p>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API\">MDN The WebSocket API 문서</a></p>\n</blockquote>\n<blockquote>\n<p>Socket.IO enables real-time, bidirectional and event-based communication.\nIt works on every platform, browser or device, focusing equally on reliability and speed.</p>\n<p>대표적인 소켓 통신 라이브러리. <a href=\"https://socket.io/\">Socket.IO 공식 사이트</a></p>\n</blockquote>\n<h3 id=\"pubsub-게시자-구독자-패턴-비동기-메세징-api\">PubSub: 게시자-구독자 패턴. 비동기 메세징 API</h3>\n<blockquote>\n<p>SUBSCRIBE, UNSUBSCRIBE and PUBLISH implement the Publish/Subscribe messaging paradigm where (citing Wikipedia) senders (publishers) are not programmed to send their messages to specific receivers (subscribers). Rather, published messages are characterized into channels, without knowledge of what (if any) subscribers there may be.\nSubscribers express interest in one or more channels, and only receive messages that are of interest, without knowledge of what (if any) publishers there are. This decoupling of publishers and subscribers can allow for greater scalability and a more dynamic network topology.</p>\n<p><a href=\"https://redis.io/topics/pubsub\">Redis Pub/Sub 공식 문서</a></p>\n</blockquote>","data":{"tocTree":[]},"permanlink":"/api-layer/","tags":["작성 중","DDD","계층형 아키텍처","API","REST","gRPC","GraphQL","WebSocket","PubSub"]},{"slug":"python-async-db","frontmatter":{"title":"파이썬 비동기 DB 비교 - 1. 큰 그림","excerpt":"파이썬에서 비동기 DB를 SQLDriver, ORM, NoSQL까지 다양한 방법으로 구현해보고 비교해보려 합니다. 큰 그림을 그려보면서 시작합니다.","date":"2021-07-13T11:23:44.765012","author":"탐정토끼(Taehee Kim)","tag":"작성 중, 비동기, 파이썬, 데이터베이스"},"html":"<h2 id=\"asyncio-db를-다양한-방식으로-구현해보고-비교합니다\">AsyncIO DB를 다양한 방식으로 구현해보고 비교합니다.</h2>\n<h2 id=\"비동기는-쓰레드-하나single-thread로도-차단blocking-없이-더-많은-요청을-처리할-수-있습니다\">비동기는 쓰레드 하나(single thread)로도 차단(Blocking) 없이 더 많은 요청을 처리할 수 있습니다.</h2>\n<h2 id=\"파이썬에서는-asyncio와-asyncawait-키워드로-비동기를-처리합니다\">파이썬에서는 AsyncIO와 async/await 키워드로 비동기를 처리합니다.</h2>\n<h2 id=\"다양한-db를-사용해서-구현해보고-비교해봅니다\">다양한 DB를 사용해서 구현해보고 비교해봅니다.</h2>\n<h3 id=\"sql-driver--sqliteaiosqlite-postgresqlasyncpg\">SQL Driver : SQLite/aiosqlite, PostgreSQL/asyncpg</h3>\n<h3 id=\"orm-객체-관계-맵퍼--sqlalchemy-tortoise\">ORM 객체 관계 맵퍼 : SQLAlchemy, Tortoise</h3>\n<h3 id=\"next-generation--edgedb\">Next-Generation? : EdgeDB</h3>\n<h3 id=\"key-value-키-값--redisasync-redis\">Key-Value 키-값 : Redis/async-redis</h3>\n<h3 id=\"document--mongodbmotor\">Document : MongoDB/Motor</h3>\n<h3 id=\"graph--neo4jaioneo4j\">Graph : Neo4j/aioneo4j</h3>","data":{"tocTree":[]},"permanlink":"/python-async-db/","tags":["작성 중","비동기","파이썬","데이터베이스"]},{"slug":"what-is-asynchronous","frontmatter":{"title":"비동기(asynchronous)","excerpt":"비동기는 DB나 네트워크 요청 등을 차단 없이 처리할 수 있습니다. 개념을 설명하고, 흔한 오해를 풀어봅니다.","date":"2021-07-13T11:22:34.832910","author":"탐정토끼(Taehee Kim)","tag":"작성 중, 비동기, 동시성, 병렬성, Blocking"},"html":"","data":{"tocTree":[]},"permanlink":"/what-is-asynchronous/","tags":["작성 중","비동기","동시성","병렬성","Blocking"]},{"slug":"hljs-elder-blog","frontmatter":{"title":"highlight.js로 코드블럭 문법 강조하기","excerpt":"Elder.js 기본 템플릿에 highlight.js를 이용해서 코드블럭 문법 강조(syntax highlight)를 넣어봅시다.","date":"2021-07-11T13:27:22.262492","author":"탐정토끼(Taehee Kim)","tag":"작성 중, Elder.js, Blog, syntax highlighting"},"html":"<h2 id=\"higliightjs\">higliight.js</h2>","data":{"tocTree":[]},"permanlink":"/hljs-elder-blog/","tags":["작성 중","Elder.js","Blog","syntax highlighting"]},{"slug":"category-for-functional","frontmatter":{"title":"함수형 프로그래밍을 위한 카테고리 이론","excerpt":"수학까지 해야하나? 함수형 프로그래밍의 근간이 되는 카테고리 이론과 학습 자료를 소개합니다.","date":"2021-07-10T10:03:01.321Z","author":"탐정토끼(Taehee Kim)","tag":"작성 중, 함수형, 카테고리 이론"},"html":"<p>latex 테스트</p>\n<p>함수 합성</p>\n<p>ℎ ∘ (𝑔 ∘ 𝑓 ) = (ℎ ∘ 𝑔) ∘ 𝑓 = ℎ ∘ 𝑔 ∘ 𝑓</p>\n<h2 id=\"remark-math-katex\">remark math katex</h2>\n<div class=\"math math-display\"><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>h</mi><mo>∘</mo><mo stretchy=\"false\">(</mo><mi>g</mi><mo>∘</mo><mi>f</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mo stretchy=\"false\">(</mo><mi>h</mi><mo>∘</mo><mi>g</mi><mo stretchy=\"false\">)</mo><mo>∘</mo><mi>f</mi><mo>=</mo><mi>h</mi><mo>∘</mo><mi>g</mi><mo>∘</mo><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">h \\\\circ (g \\\\circ f) = (h \\\\circ g) \\\\circ f = h \\\\circ g \\\\circ f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">h</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∘</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∘</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">h</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∘</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∘</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">h</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∘</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.63889em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∘</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span></span></div>","data":{"tocTree":[]},"permanlink":"/category-for-functional/","tags":["작성 중","함수형","카테고리 이론"]},{"slug":"string-std","frontmatter":{"title":"문자열 String std 파고들기","excerpt":"문자열은 대충 생각하면 문자의 배열이지만, 실제로는 더 복잡합니다. 문자열을 0101 이진수로 저장하는 방법. 유니코드, UTF-8와 같은 인코딩에 대해 알아봅니다.","date":"2021-07-08T15:26:07.156Z","author":"탐정토끼(Taehee Kim)","tag":"작성 중, std, 문자열, 표준 라이브러리"},"html":"<p>std 시리즈에서는 서로 다른 언어들의 표준 라이브러리와 자료형, 문법을 비교해보고자합니다.</p>\n<p>std는 standard 표준의 약자로, 보통 그 언어의 표준 라이브러리를 std라고 부릅니다. 언어마다 표준은 다르며, 각자 나름대로 그런 표준을 선택한 이유와 배경이 있습니다. 여기서는 다양한 언어들의 표준 라이브러리로 대표적인 작업을 처리하는 예시 코드를 보여드립니다. 직접 REPL 등에 하나씩 쳐보시면서 익혀보시면 더욱 좋겠죠.</p>\n<p>하지만 코드만 봐서는 원리는 알기 어렵습니다. 문자열은 언어마다 어떻게 구현되어 있으며, 이게 어떤 쓸모가 있을까요? 기본적으로는 재미로 알아 보자는 거지만. 이런 지식이 도움이 되는 때도 있을 겁니다.</p>\n<ul>\n<li><a href=\"/string-encoding/\">문자, 문자열, 한글 인코딩</a></li>\n<li><a href=\"/string-immutable/\">문자열은 왜 불변인가?</a></li>\n</ul>\n<h2 id=\"프로그래밍-언어별-string-표준-라이브러리\">프로그래밍 언어별 String 표준 라이브러리</h2>\n<h3 id=\"java-char-char-string\">Java: char, Char, String</h3>\n<pre><code class=\"language-java\">String foo = \"탐정토끼\";\nchar f = '탐'; // 글자와 String을 구분한다.\n\nString foo_copy = foo;\nfoo_copy += \"입니다.\";\nSystem.out.println(foo);\n// 탐정토끼  &#x3C;- 원래 값은 불변\nSystem.out.println(foo_copy);\n// 탐정토끼입니다. \n\n// 길이\nassertEqual(foo.length(), 4);\n\nassertEqual(foo.charAt(0), '탐');\nassertEqual(foo.substring(1), \"정토끼\");\nassertEqual(foo.substring(1, 3), \"정토\"); // 마지막 인덱스 미포함\nassertEqual(foo.substring(foo.length() - 2), \"토끼\"); // 마지막 2 글자\n\n// 뒤집기\nStringBuffer sb = new StringBuffer(str);\nString reversedFoo = sb.reverse().toString();\nSystem.out.println(reversedFoo);\n\n// 바꾸기\nassertEqual(\"2014/02/14\".replaceAll(\"/\", \"-\"), \"2014-02-14\");\n// 쪼개기\nfor (String item: \"2014/02/14\".split(\"/\")){\n  System.out.println(item);\n}\nassertEqual(\"2014/02/14\".split(\"/\"), [\"2014\", \"02\", \"14\"]);\n\nassertEqual(String.valueOf(24) + \"시간이 모자라\", \"24시간이 모자라\");\n// \"1\" &#x3C; \"3\" &#x3C;- 비교 불가\n// error: bad operand types for binary operator '&#x3C;'\n\nassertEqual(\"taehee\" + \" \" + \"kim\", \"taehee kim\"); // 합치기\nString[] arr = new String[] {\"탐정\", \"토끼\"};\nassertEqual(String.join(\"\", arr), \"탐정토끼\");\n\nString html = \"\"\"\n  &#x3C;html>\n    &#x3C;body>\n      &#x3C;p>Hello, world&#x3C;/p>\n    &#x3C;/body>\n  &#x3C;/html>\n\"\"\"; // 자바15부터 가능\n\n// 주어진 문자열을 포함하는지?\nassertTrue(foo.contains(\"탐정\"));\n\n// 주어진 문자열로 시작하는지?\nassertTrue(\"https://twinstae.github.io/\".startswith(\"https\"));\n// 주어진 문자열로 끝나는지?\nassertTrue(\"fiesta-izone.mp3\".endswith(\".mps\"));\n\nString name = \"kim\";\n// 비어있는지?\nassertFalse(name.isBlank());\n\nassertEqual(String.format(\"hello, %s\", name), \"hello, kim\");\n\n// 소문자로\nassertEqual('TAEhee Kim'.toLowerCase(), \"taehee kim\") \n// 공백 자르기\nassertEqual('    내용     \\\n   '.trim(), \"내용\")\n\n// 메소드 체이닝\nString raw_text = \"    \\\n         TeST HeLLo WORld      \\\n \\\n \\\\t   \";\nString[] expected = new String[] {'test', 'hello', 'world'};\nassertEqual(raw_text.trim().toLowerCase().split(\" \"), expected);\n</code></pre>\n<h3 id=\"python-str\">Python: str</h3>\n<pre><code class=\"language-python\">foo = \"탐정토끼\" # 리터럴\nassert type(foo) == type(\"탐\") # 글자 하나의 타입도 str\n# &#x3C;class 'str'>\n\nfoo_copy = foo // 값을 복사\nfoo_copy += \"입니다.\"\nprint(foo) \n// \"탐정토끼\" 원래 값은 불변\nprint(foo_copy)\n// \"탐정토끼입니다.\"\n\nassert len(foo) == 4 # 문자열의 길이\n\n# 문자열[start : end : step]\nassert foo[0] == \"탐\"  # 문자 가져오기\nassert foo[1:] == \"정토끼\" # 자르기. start 부터 끝까지\nassert foo[1:3] == \"정토\"  # 마지막 인덱스는 미포함\nassert foo[-2:] == \"토끼\"  # 마지막 2글자\nassert \"abcdefg\"[::2] == \"aceg\" # step 2칸씩 \n\nprint(foo[::-1]) # 뒤집기\n# \"끼토정탐\"\n\nassert \"2014/02/14\".replace(\"/\", \"-\") == \"2014-02-14\" # 치환\nassert \"2014/02/14\".split(\"/\") == [\"2014\", \"02\", \"14\"] # 쪼개기\n\nassert str(24) + \"시간이 모자라\" # int와 문자열 합치기\n# \"24시간이 모자라\"\nassert \"1\" &#x3C; \"3\" # 비교 가능\n\nassert \"taehee\" + \" \" + \"kim\" == \"taehee kim\" # 합치기\nassert \"\".join([\"탐정\", \"토끼\"]) == \"탐정토끼\" # 연결하기\n\nlong_csv = \"\"\"12, 3, \"빨강\"\n13, 2, \"파랑\"\n14, 1, \"초록\"\n\"\"\" # 여러 줄 문자열\nlong_csv.split(\"\\\n\") # 줄 단위로 자르기\n\nassert \"탐정\" in foo == True # foo가 \"탐정\"을 포함하는지? \n# 주어진 문자열로 시작하는지?\nassert \"https://twinstae.github.io/\".startswith(\"https\") == True\n# 주어진 문자열로 끝나는지?\nassert \"fiesta-izone.mp3\".endswith(\".mps\")\n\nname: str = 'kim' # 타입힌트, ' 홑 따옴표도 상관 없다.\n\nassert not name == True;   # 비어 있는지? PEP8 가이드 권장\n# \"name != \"\"               # 이렇게 할 수도 있긴 하다.\n\nprint('hello, %s' % name) # format\n# 'hello, kim'\nprint(f'hello, {name}')   # interpolation\n# 'hello, kim'\n\nprint('TAEhee Kim'.lower()) # 소문자로\n# 'taehee kim'\n'    내용     \\\n   '.strip()  # 공백 자르기\n# '내용'\n\n# 메소드 체이닝\nraw_text = \"    \\\n         TeST HeLLo WORld      \\\n \\\n \\\\t   \"\nraw_text.strip().lower().split(\" \")\n# ['test', 'hello', 'world']\n\nm = re.search('([1-6])학년 ([0-9]{1,2})단원', '2학년 3단원')\nassert m.group(0) == '2학년 3단원'\nassert m.group(1) == '2'\nassert m.group(2) == '3'\n</code></pre>\n<h3 id=\"typescript-string\">TypeScript: string</h3>\n<pre><code class=\"language-typescript\">const foo: string = \"탐정토끼\";\nconsole.log(foo.split(\"\").reverse().join());\n</code></pre>\n<h3 id=\"rust-str-stdstring\">Rust: str, std::String</h3>\n<pre><code class=\"language-rust\">let foo = \"탐정토끼\";\nprintln!(\"{}\", foo.chars().rev().collect::&#x3C;String>());\n</code></pre>\n<h3 id=\"clojure-javalangcharacter-javalangstring\">Clojure: java.lang.Character, java.lang.String</h3>\n<pre><code class=\"language-clojure\">(require '[clojure.string :as s])\n(def foo \"탐정토끼\")\n\n(count foo) ; 길이\n; 4\n\n(get foo 0) ; 문자 가져오기\n; \\\\탐\n(subs foo 1) ; 자르기. start 부터 끝까지\n;\"정토끼\"\n(subs foo 1 3) ; 마지막 인덱스는 미포함\n;\"정토\"\n(subs foo (- (count foo) 2)) ; 마지막 2글자\n;\"토끼\"\n\n(print (s/reverse foo)) ; 뒤집기\n\n(s/replace \"2014/02/14\" \"/\", \"-\") ; 바꾸기\n; \"2014-02-14\"\n(s/split \"2014/02/14\" #\"/\") ; 쪼개기 #은 정규표현식 표시\n; (\"2014\" \"02\" \"14\")\n\n(def long-csv \"12, 3, \\\\\"빨강\\\\\"\n13, 2, \\\\\"파랑\\\\\"\n14, 1, \\\\\"초록\\\\\"\n\")\n(s/split-lines long-csv)\n\n(s/includes? foo \"탐정\") ; foo가 \"탐정\"을 포함하는지?\n(s/startswith? \"https://twinstae.github.io/\" \"https\") ; 시작하는지?\n(s/ends-with? \"fiesta-izone.mp3\" \".mp3\") ; 끝나는지?\n\n(s/blank? foo) ; 비어있는지?\n\n(str \"taehee\" \" \" \"kim\") ; 합치기\n; \"taehee kim\"\n(str 24 \"시간이 모자라\") ; int와 문자열 합치기. 자동 형 변환.\n; \"24시간이 모자라\"\n\n; (&#x3C; \"1\" \"3\")\n; 비교 불가 .String cannot be cast to class java.lang.Number\n\n(s/join \" \" [\"탐정\" \"토끼\" \"입니다.\"]) ; 붙이기\n; \"탐정 토끼 입니다.\"\n\n(format \"hello, %s\" foo) ; 포맷\n; \"hello, 탐정토끼\"\n\n(s/lower \"TAEhee Kim\")\n; \"taehee kim\"\n(s/trim \"    내용     \\\n   \")\n; \"내용\"\n\n; 파이프\n(def raw_text \"    \\\n         TeST HeLLo WORld      \\\n \\\n \\\\t   \")\n(-> raw_text s/trim s/lower-case (s/split #\" \"))\n; [\"test\" \"hello\" \"world\"]\n</code></pre>\n<h3 id=\"elixir-stringgrapheme-stringt\">Elixir: String.grapheme(), String.t()</h3>\n<pre><code class=\"language-elixir\">foo = \"탐정토끼\"\nIO.puts String.reverse(foo)\n</code></pre>","data":{"tocTree":[]},"permanlink":"/string-std/","tags":["작성 중","std","문자열","표준 라이브러리"]},{"slug":"brief-history-of-web-front","frontmatter":{"title":"웹 프런트 엔드의 간략한 역사","excerpt":"태초의 HTML 정적 파일부터, 템플릿 엔진, CSR, SPA, SSR, JAM Stack 에 이르기까지 웹 프런트 엔드가 진화해온 과정","date":"2021-07-08T07:30:58.196Z","author":"탐정토끼(Taehee Kim)","tag":"작성 중, front-end, CSR, SPA, SSR, JAM Stack"},"html":"<h2 id=\"static-file-정적-파일을-서빙하기---나모-웹-에디터\">Static File 정적 파일을 서빙하기 - 나모 웹 에디터</h2>\n<p>{{keyword}}Static File{{/keyword}} 을 서빙하기</p>\n<h3 id=\"웹-브라우저-주소-창에-url을-치면-일어나는-일\">웹 브라우저 주소 창에 URL을 치면 일어나는 일</h3>\n<h3 id=\"정적-파일static-file-html-css-js-이미지\">정적 파일(static file) HTML, CSS, JS, 이미지</h3>\n<h3 id=\"url과-폴더-기반-라우팅\">url과 폴더 기반 라우팅</h3>\n<h2 id=\"ssr-서버에서-템플릿-동적으로-렌더링하기---템플릿-엔진\">SSR 서버에서 템플릿 동적으로 렌더링하기 - 템플릿 엔진</h2>\n<p>{{keyword}}SSR{{/keyword}}이란...</p>\n<h3 id=\"실시간으로-변하는-상태state에-따라-다른-내용을-보여주고-싶다\">실시간으로 변하는 상태(state)에 따라 다른 내용을 보여주고 싶다.</h3>\n<h3 id=\"동적-dynamic-렌더링이란\">동적 (dynamic) 렌더링이란?</h3>\n<h2 id=\"csr-클라이언트에서-렌더링하기---jquery와-ajax-모던-js\">CSR 클라이언트에서 렌더링하기 - JQuery와 Ajax, 모던 JS</h2>\n<h3 id=\"사용자-동작에-따라-반응하게-만들고-싶다\">사용자 동작에 따라 반응하게 만들고 싶다.</h3>\n<h2 id=\"spa-웹-앱을-만들자---angular-vue-react\">SPA 웹 앱을 만들자 - Angular, Vue, React</h2>\n<h3 id=\"새로고침-없이-브라우저에서-동적으로-dom을-그리고-싶다\">새로고침 없이 브라우저에서 동적으로 dom을 그리고 싶다.</h3>\n<h2 id=\"ssr이-spa와-함께-부활하다---nextjs\">SSR이 SPA와 함께 부활하다 - Next.js</h2>\n<h3 id=\"빠르게-사이트를-보여주고-멍청한-검색엔진-크롤러에게-html을-보여주고-싶다\">빠르게 사이트를 보여주고, 멍청한 검색엔진 크롤러에게 HTML을 보여주고 싶다</h3>\n<h2 id=\"정적-파일이-현대-기술과-함께-돌아오다---jam\">정적 파일이 현대 기술과 함께 돌아오다 - JAM</h2>\n<h3 id=\"복잡한-webserver-없이-빠르게-웹-사이트를-보여주고-싶다\">복잡한 WebServer 없이 빠르게 웹 사이트를 보여주고 싶다.</h3>\n<blockquote>\n<ul>\n<li><a href=\"https://jamstack.org/\">잼스택 홍보 사이트</a></li>\n<li><a href=\"https://www.itworld.co.kr/news/156752\">잼스택, 웹 개발을 뒤집는 정적 웹사이트 혁명 : IT World 번역 기사</a></li>\n<li><a href=\"https://pks2974.medium.com/jam-stack-%EA%B0%9C%EB%85%90-%EC%A0%95%EB%A6%AC%ED%95%98%EA%B8%B0-17dd5c34edf7\">JAM Stack 개념 정리하기 : 박성룡님 블로그</a></li>\n</ul>\n</blockquote>\n<h2 id=\"진화는-일직선이-아니다\">진화는 일직선이 아니다.</h2>\n<h2 id=\"각-방식의-장-단점-총-정리\">각 방식의 장, 단점 총 정리</h2>","data":{"tocTree":[]},"permanlink":"/brief-history-of-web-front/","tags":["작성 중","front-end","CSR","SPA","SSR","JAM Stack"]},{"slug":"what-is-trade-off","frontmatter":{"title":"Trade Off 트레이드 오프","excerpt":"Trade Off란 교환 관계에 있다는 뜻이다. 즉 어떤 언어나 기술을 선택했을 때 얻는 게 있으면, 잃는 것도 있다는 뜻으로 쓴다.","date":"2021-07-08T07:20:00.196Z","author":"탐정토끼(Taehee Kim)","tag":"작성 중, 개념어, Trade Off"},"html":"<p>사전적 정의 : 교환, 마치 양팔 저울처럼 한 쪽을 늘리면, 다른 한 쪽을 잃게 된다는 뜻.\n여러 언어나 기술에는 각자 장, 단점이 있으니 내 상황에 맞게 올바른 기술을 선택해야한다는 뜻으로 쓰입니다.</p>","data":{"tocTree":[]},"permanlink":"/what-is-trade-off/","tags":["작성 중","개념어","Trade Off"]},{"slug":"customize-elder-blog","frontmatter":{"title":"Elder 블로그 커스터마이징 하기","excerpt":"Elder 기본 템플릿에 웹 폰트, 날짜 순 정렬, tooltip 같은 기능들을 추가해봅니다.","date":"2021-07-08T05:01:27.798Z","author":"탐정토끼(Taehee Kim)","tag":"작성 중, Svelte, Elder.js, Blog"},"html":"<p>이번에는 Elder.js의 구조를 살펴보고 간단하게 레이아웃을 수정해보겠습니다.</p>\n<p>저번에는 Elder.js 템플릿을 가져와서 GitHub Pages에 배포도 해봤습니다. 이제 템플릿을 커스텀해서, 나만의 블로그를 만들 시간입니다.</p>\n<p>일단 가볍게 전체 구조를 살펴보고, 기능들을 만들면서 하나씩 배워보겠습니다. 다음 프로젝트 구조를 구경만 해보세요. 이런 게 있구나 알아보시기만 하면 됩니다.</p>\n<h2 id=\"elderjs-프로젝트-구조\">Elder.js 프로젝트 구조</h2>\n<ul>\n<li>node_modules : 저희가 설치한 각종 모듈들</li>\n<li>assets : 전체 기본 css, 이미지, robots.txt 등이 들어갑니다.\n<ul>\n<li>style.css</li>\n</ul>\n</li>\n<li>src : 프로젝트 소스 파일\n<ul>\n<li>components : 스벨트 컴포넌트\n<ul>\n<li>BlogTeaser.svelte</li>\n<li>...</li>\n</ul>\n</li>\n<li>layouts : 기본 레이아웃. 틀</li>\n<li>routes : 파일 시스템 기반 URL\n<ul>\n<li>blog : 블로그 글\n<ul>\n<li>Blog.svelte : 블로그 페이지의 스벨트 컴포넌트</li>\n<li>route.js : url 과 데이터 설정</li>\n<li>&#x3C;글의 slug>.md : 마크다운으로 쓴 글 본문</li>\n</ul>\n</li>\n<li>home : 초기 화면\n<ul>\n<li>Home.svelte</li>\n<li>route.js</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>docs : 실제로 생성된 사이트 파일</li>\n<li>build.js</li>\n<li>cleanPublic.js : docs 폴더를 정리해줌</li>\n<li>hook.js</li>\n<li>server.js</li>\n<li>shortcodes.js</li>\n</ul>\n</li>\n<li>.gitignore : 저번에 만든 git에 올리지 않을 파일 목록</li>\n<li>.nojekyll : 깃허브에게 jekyll 을 쓰지 않는다고 알려주는 파일</li>\n<li>elder.config.js : 엘더 js 설정</li>\n<li>esbuild.js : esbuild 설정</li>\n<li>rollup.config.js : 롤업 설정</li>\n<li>svelte.config.js : 스벨트 설정</li>\n<li>package.json : 프로젝트 의존성, 스크립트 등 설정</li>\n</ul>\n<p>처음 배울 때에는 원래 정신이 없기 마련입니다. 일단 내게 필요한 기능을 만드는데 필요한 부분만 조금씩 배워보겠습니다.</p>\n<h2 id=\"새로운-글쓰기-불필요한-글-지우기\">새로운 글쓰기. 불필요한 글 지우기.</h2>\n<p>먼저 src/routes/blog/route.js 를 열어보면 다음과 같은 내용이 보이실 겁니다.</p>\n<pre><code class=\"language-javascript\">module.exports = {\n // 마크다운 플러그인이\n // data와 all의 내용을 채워준다는 설명\n  data: {},\n  all: () => [],\n  permalink: '/:slug/',\n};\n</code></pre>\n<p>일단 permanent link는 앞으로 몇 년 동안 이 페이지로 접근할 수 있는 URL은 이곳임을 알려주는 표시입니다. 검색엔진은 이 URL을 믿고 사람들을 데려오기 때문에 때문에 마음대로 permalink가 바뀌면 안 됩니다. {{keyword}}SEO{{/keyword}}에 중요한 이유를 아시겠죠?</p>\n<p>여기서는 permanlink 가 /:slug/ 모양이라고 템플릿을 만들어놨습니다. 여기서 slug는 url에 쓸 수 있게 띄어쓰기 대신 - 등으로 연결한 글 제목인데요. 영어로 쓴 마크다운 파일 제목이 slug가 됩니다. 예를들어 <code>getting-started.md</code> 파일은 .md 확장자를 빼버리고 <code>/getting-started/</code>가 url이 됩니다. 중요한 건 파일 이름을 일단 영문 알파벳으로 해줘야한다는 점입니다.</p>\n<p>그러면 Blog.svelte를 살펴보러 가겠습니다. data와 all을 마크다운 플러그인이 어떻게 채워줬을까요?</p>\n<p>코드를 열어보시면 맨 위에 script가 있습니다.</p>\n<pre><code class=\"language-html\">&#x3C;script>\n  export let data, request; // data의 내용은 markdown plugin이 외부에서 넣어줌.\n  const { html, frontmatter } = data;\n&#x3C;/script>\n</code></pre>\n<p>export let 으로 data와 request를 선언해놓으면, 마크다운 플러그인이 값을 넣어줍니다. data를 구조 분해할당해서 html과 frontmatter 를 꺼내오는데요. 구조 분해 할당을 잘 모르신다면 다음과 같은 코드를 줄여 쓴거라고 생각하시면 됩니다.</p>\n<pre><code class=\"language-javascript\">// 전통적인 방법.\nconst html = data.html;\nconst frontmatter = data.html;\n\n// 구조 분해 할당\nconst { html , frontmatter } = data;\n</code></pre>\n<p>그러면 html이랑 frontmatter는 어디서 왔을까요? 마크다운 플러그인이 blog 폴더에 있는 <code>.md</code> 파일들을 찾아서 변환한 겁니다.</p>\n<p><code>getting-started.md</code> 마크다운 파일을 하나 열어보면 이렇게 생겼습니다.</p>\n<p>위에 title부터 author 까지가 frontmatter입니다. 그 다음에 이어지는 본문 마크다운이 html로 변환됩니다. 마크다운은 html을 편리하게 쓰기 위한 문법입니다. 인터넷에 검색해보시면 마크다운 문법을 쓰는 방법을 설명한 글이 많으니, 잘 모르신다면 이번 기회에 한 번 배워보세요.</p>\n<pre><code>---\ntitle: 'Getting Started with Elder.js'\nexcerpt: 'You have the starter template of Elder.js running. So what is next? This guide will help you explore the project.'\ndate: '2020-03-16T05:35:07.322Z'\nauthor: Nick Reese\n---\n\nSweet! So you've got the Elder.js starter template up and running. What's next?\n\n## 4 Routes To Explore\n\nThis project is structured to follow the required Elder.js folder structure which you can see below, but in short you've got several routes in the `./src/routes/` folder.\n</code></pre>\n<p>그러면 이렇게 변환한 html과 frontmatter로 뭘 어떻게 하는 걸까요? 다시 <code>Blog.svelte</code>로 돌아가 봅시다.</p>\n<p><code>&#x3C;style></code> 태그를 지나치면 <code>&#x3C;svelte:head></code>가 나옵니다. 이 친구는 역시 검색엔진에게 이런저런 정보를 알려주기 위한 정보를 html header에 추가해줍니다.</p>\n<p><code>&#x3C;title></code>은 말 그대로 글의 제목입니다. 탭에 제목이 뜨게 되고, frontmatter에 적어놨던 title을 가져옵니다. svelte에서는 html에 js 값을 넣을 때 {}로 감싸줍니다. 예를 들어 title에 값을 채워넣으면 다음과 같이 렌더링될 겁니다.</p>\n<p><code>&#x3C;title>Svelte Elder.js 블로그 만들기&#x3C;/title></code></p>\n<p>다음으로 <code>&#x3C;meta name=\"description\"</code>은 페이지가 어떤 내용인지 설명합니다. 여기서는 frontmatter에 적어놨던 excerpt를 가져옵니다. excerpt는 발췌라는 뜻인데. 보통 글의 첫 부분 내용을 가져옵니다. 검색엔진에 미리보기로 뜨는 그 내용입니다.</p>\n<p>마지막으로 <code>&#x3C;link></code>는 아까 정해뒀던 permanlink를 넣어줍니다. 검색엔진에게 premanlink는 이거라고 알려주는 부분입니다.</p>\n<p>그 다음은 이제 화면의 내용을 HTML로 본격적으로 그리게 됩니다.</p>\n<pre><code class=\"language-html\">&#x3C;a href=\"/\">&#x26;LeftArrow; Home&#x3C;/a> // 블로그 홈으로 돌아가기\n\n&#x3C;div class=\"title\">\n  &#x3C;h1>{frontmatter.title}&#x3C;/h1> // 제목\n  {#if frontmatter.author}&#x3C;small>By {frontmatter.author}&#x3C;/small>{/if} // 글쓴이가 있으면 표시\n&#x3C;/div>\n\n{#if html} // html이 있으면\n  {@html html} // html을 표시\n{:else}\n  &#x3C;h1>Oops!! Markdown not found!&#x3C;/h1>\n{/if}\n</code></pre>\n<p>여기서 중요한 친구는 {#if 조건} 내용 {/if} 구문입니다. 스벨트는 옛날 템플릿 언어들을 닮았습니다. html에 리액트처럼 ? 삼항 연산자나 &#x26;&#x26; 문을 쓰지 않고, 이렇게 if 템플릿 안에 html을 넣어줍니다.</p>\n<p>마찬가지로 frontmatter에서 title과 author를 꺼내서 넣었고요. 아까 같이 data에서 꺼냈던 html도 넣어줬습니다.</p>\n<p>@html 은 html을 있는 그대로 삽입하기 위한 명령어입니다. 시험삼아 @html을 지우고 npm run dev로 서버를 실행해보세요. 글로 들어가면 렌더링 되지 않은 HTML 코드 자체가 보일 겁니다. @html이 있어야 html을 내용 그대로 삽입할 수 있습니다.</p>\n<h2 id=\"게시글-목록-날짜-순으로-정렬하기\">게시글 목록 날짜 순으로 정렬하기</h2>\n<h2 id=\"게시글-목록에-날짜-달기\">게시글 목록에 날짜 달기</h2>","data":{"tocTree":[]},"permanlink":"/customize-elder-blog/","tags":["작성 중","Svelte","Elder.js","Blog"]},{"slug":"svelte-elder-create-blog","frontmatter":{"title":"Svelte Elder.js 블로그 만들기","excerpt":"검색 엔진 최적화(SEO)된 Svelte 정적 페이지 생성기인 ElderJS로 블로그 만드는 과정을 설명합니다.","date":"2021-07-07T15:01:00.618Z","author":"탐정토끼(Taehee Kim)","tag":"Svelte, Elder.js, Github Pages, Blog"},"html":"<p>이 블로그는 <a href=\"https://svelte.dev/\">Svelte</a>와 <a href=\"https://elderguide.com/tech/elderjs/\">Elder.js</a>로 만들었습니다. 이 글에서는 여러분에게 Svelte와 Elder.js를 소개하고, 여러분도 비슷한 블로그를 만들 수 있게 도와드리려 합니다.</p>\n<h2 id=\"필요한-것--html-css-js--nodejs-설치--github-계정\">필요한 것 : HTML, CSS, JS / Node.js 설치 / GitHub 계정</h2>\n<p>제 블로그는 초보도 쉽게 따라할 수 있도록 자세하고 친절하게 쓰려 합니다. 이미 많이 알고 계시는 분들은 큰 제목 위주로 빠르게 읽어 내려가시면 되겠습니다.</p>\n<ul>\n<li>HTML, CSS, JS에 대해 기본적인 지식이 있어야합니다.\n<ul>\n<li>잘 모른다면 <a href=\"https://opentutorials.org/course/3083\">생활코딩 WEBn</a> 강좌로 시작하길 권해드립니다.</li>\n</ul>\n</li>\n<li><a href=\"https://nodejs.org/ko/download/\">Node.JS</a>가 설치되어 있고, NPM 을 사용할 수 있어야 합니다.\n<ul>\n<li><a href=\"https://opentutorials.org/course/3332/21029\">생활코딩 Node.js 설치</a> 강의 영상을 참고하세요.</li>\n</ul>\n</li>\n<li>GitHub 계정이 있고, Git을 사용할 줄 알아야 합니다.\n<ul>\n<li><a href=\"https://opentutorials.org/course/3837\">생활코딩 GIT1</a>, <a href=\"https://opentutorials.org/course/307/2475\">생활코딩 GitHub</a> 강좌도 있습니다. (없는 게 없네요!)</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"이론--svelte-와-elderjs-를-소개합니다\">이론 : Svelte 와 Elder.js 를 소개합니다.</h2>\n<p>이 두 친구와 {{keyword}}SEO{{/keyword}}, {{keyword}}JAM Stack{{/keyword}} 등에 대해 이미 잘 알고 계신다면 바로 실전으로 넘어가셔도 됩니다.</p>\n<h3 id=\"svelte는-가상-돔-없이-바닐라js에-가깝게-개발할-수-있는-웹-프레임워크입니다\">Svelte는 가상 돔 없이 바닐라JS에 가깝게 개발할 수 있는 웹 프레임워크입니다.</h3>\n<p><img src=\"https://camo.githubusercontent.com/c0334ff12149f79bcf27d97aca688ddb72c989c09c3f6b9db0a93d59cb1bbc28/68747470733a2f2f7376656c74656a732e6769746875622e696f2f6173736574732f62616e6e65722e706e67\" alt=\"Svelte 로고가 들어간 배너\"></p>\n<blockquote>\n<p>출처 : Svelte 깃허브 배너</p>\n</blockquote>\n<p>Svelte는 요즘 유명해졌습니다. Angular, React, Vue 3대장을 이은 다크호스로 주목 받고 있죠. 물론 Svelte가 뭔지 모르시는 분도 있을 겁니다.</p>\n<p>Svelte가 도대체 뭐길래? 공식 홈페이지에서는 다음 3가지 특징을 밀고 있습니다.</p>\n<ul>\n<li>Write less code : HTML, CSS, {{keyword}}바닐라JS{{/keyword}}에 가깝게 코딩할 수 있고요. 복잡한 보일러 플레이트가 거의 없습니다.</li>\n<li>No virtual DOM : 가상 돔 같은 프레임워크 오버헤드 없이, 가벼운 바닐라 JS 코드로 컴파일됩니다. <a href=\"https://miro.medium.com/max/2000/1*6HK361f-UDqNpWuTA68jHw.png\">번들 용량이 놀라울 정도로 작습니다</a>.</li>\n<li>Truly reactive : 복잡한 상태 관리 라이브러리 없이도, 쉽게 상태를 관리하고, 변화에 '반응'해서 빠르고 정확하게 UI를 변경합니다.</li>\n</ul>\n<p>다음은 이 블로그 게시글 목록에 있는 카드를 만드는 스벨트 컴포넌트입니다.</p>\n<pre><code class=\"language-html\">// BlogTeaser.svelte\n&#x3C;script>\n  export let blog; // 컴포넌트의 prop입니다.\n  export let helpers;\n\n  // ISO 포맷인 날짜를 사람이 읽을 수 있는 모양으로 변환합니다.\n  const formattedDate = new Intl.DateTimeFormat(\n    \"ko-KR\", {\n      dateStyle: \"long\",\n      timeStyle: \"short\"\n    })\n    .format(new Date(blog.frontmatter.date));\n&#x3C;/script>\n\n&#x3C;!-- 리액트처럼 {} 안에 js 코드를 넣을 수 있습니다. -->\n&#x3C;a href={helpers.permalinks.blog({ slug: blog.slug })}>\n&#x3C;div class=\"entry card\">\n    &#x3C;h3>{blog.frontmatter.title}&#x3C;/h3>\n  &#x3C;span class=\"date-badge\">\n    {formattedDate}\n  &#x3C;/span>\n  &#x3C;p>{blog.frontmatter.excerpt}&#x3C;/p>\n&#x3C;/div>\n&#x3C;/a>\n\n\n&#x3C;!--\ncss도 평범하게 사용하면 됩니다.\nscope가 해당 컴포넌트 안으로 제한되기 때문에\n복잡한 className 없이도 selector를 간단하게 유지할 수 있습니다.\n-->\n&#x3C;style>\n  span.date-badge {\n    color: gray;\n    font-size: 80%;\n    width: fit-content;\n  }\n\n  h3 {\n    margin: 0;\n    color: var(--primary);\n  }\n\n  p {\n    margin: 0.25rem;\n    color: var(--primary-text);\n  }\n&#x3C;/style>\n</code></pre>\n<p>Svelte 홈페이지에는 따로 설치 없이 바로 해볼 수 있는 <a href=\"https://svelte.dev/tutorial/basics\">영어 튜토리얼</a>이 있습니다.</p>\n<p>한국어 자료로는 <a href=\"https://heropy.blog/2019/09/29/svelte/\">Svete.js 완벽 가이드</a>도 있습니다. 저자 분이 인프런에서 유료 강의도 하고 계세요.</p>\n<h3 id=\"elderjs는-검색엔진에-최적화된-svelte-정적-사이트-생성기ssg입니다\">Elder.js는 검색엔진에 최적화된 Svelte 정적 사이트 생성기(SSG)입니다.</h3>\n<p><img src=\"https://github.com/elderjs/elderjs/raw/master/elderjs.png\" alt=\"할아버지를 그린 그림\"></p>\n<blockquote>\n<p>출처 : Elder.js 깃허브 배너. Elder.js는 노인 돌봄 서비스를 찾고 비교할 수 있는 https://elderguide.com 을 만들던 과정에서 탄생한 프레임워크다.</p>\n</blockquote>\n<p>Elder.js는 {{keyword}}CSR{{/keyword}}과 {{keyword}}SSR{{/keyword}}의 단점을 해결하기 위해 등장한 {{keyword}}JAM Stack{{/keyword}} 정적 사이트 생성기{{keyword}}SSG{{/keyword}}입니다. Elder.js 는 Svelte 앱을 정적인 HTML과 자그마한 컴포넌트로 분할해서 {{keyword}}Static File{{/keyword}}로 배포할 수 있게 해줍니다.</p>\n<p>{{keyword}}SEO{{/keyword}}는 블로그나 사이트를 만드는 사람이라면 신경 쓸 수 밖에 없죠. 구글이나 네이버의 크롤링 로봇들은 인터넷을 돌아다니면서 HTML 파일을 읽고 웹사이트에 어떤 내용이 있는지 정리합니다.</p>\n<p>하지만 React를 비롯한 {{keyword}}SPA{{/keyword}} 프레임워크들은 검색 엔진이 읽기 어려워합니다. 식당에서 음식을 고르려는데, 식재료와 레시피만 적혀 있는 것과 다르지 않습니다. 사용자의 웹 브라우저가 직접 html을 계산해야 하기 때문에 속도도 느리죠.</p>\n<p>그래서 서버에서 html을 렌더링하기도 합니다. 바로 {{keyword}}SSR{{/keyword}}이죠. React 기반인 Next.js가 대표적입니다. 하지만 SSR은 상대적으로 비싼 서버를 굴려야하기 때문에, 저희 같은 일반인은 물론이고 회사에게도 부담입니다.</p>\n<p>여기서 {{keyword}}JAM Stack{{/keyword}}이 등장합니다. 미리 가능한 페이지들을 정적(static) HTML 파일로 만들어서 CDN(콘텐츠 배달 네트워크)에 올려놓고, 추가로 필요한 데이터만 작은 API 서버에서 받아오게 하는 것이죠.</p>\n<p>이러면 Svelte나 React 같은 최신 프런트엔드 프레임워크를 사용하면서도, 가볍게 블로그나 사이트를 운영할 수 있습니다.</p>\n<p>이야기를 더 듣고 싶으시다면 <a href=\"https://twinstae.github.io/brief-history-of-web-front/\">웹 프런트 엔드의 간략한 역사</a>를 읽어주세요.</p>\n<p>Elder.js는 이러한 JAM 스택에서도 특히 SEO 전문가들이 만든 프레임워크입니다. 여러분의 블로그가 더 잘 검색될 수 있도록 사소한 것 하나하나 경고를 띄우고 Tip을 알려주죠. Sitemap등을 만들어주는 플러그인도 있습니다. 높은 조회수를 원하신다면, 정말 매력적인 셈이죠. :)</p>\n<p>이제 설명은 끝입니다. 실전으로 들어가보죠!</p>\n<h2 id=\"실전-elderjs-template-프로젝트-github-pages에-배포하기\">실전: Elder.js template 프로젝트 Github Pages에 배포하기</h2>\n<p>그러면 공식 가이드를 따라서, 프로젝트를 세팅해봅시다.</p>\n<p>앞서 말씀드렸듯 node.js와 함께 npm 이 설치되어 있어야합니다.</p>\n<p>잘 모르겠다면 명령 프롬프트나 터미널을 열고 다음 명령어를 쳐보세요.</p>\n<pre><code>npx --version\n# 6.14.12 이런 식으로 나오면 설치가 되어 있는 겁니다.\n</code></pre>\n<h3 id=\"npx로-elderjstemplate-세팅하기\">npx로 Elderjs/template 세팅하기</h3>\n<p>npx는 프로젝트 템플릿을 다운 받아 세팅해줍니다. 다음 명령어를 입력하면 &#x3C;내 깃허브 아이디>.github.io 라는 이름의 폴더와 기본 파일들이 생성됩니다.</p>\n<pre><code class=\"language-bash\">npx degit Elderjs/template &#x3C;내 깃허브 아이디>.github.io\n</code></pre>\n<p>저는 깃허브 아이디가 <code>twinstae</code> 이기 때문에 <code>twinstae.github.io</code>로 만들었습니다.</p>\n<p>이제 다음 명령어들을 차례차례 입력합니다. # 은 주석이니 무시하셔도 됩니다. 잘 모르는 터미널 명령어가 있다면 인터넷에 더 자세한 내용을 검색해보세요.</p>\n<pre><code class=\"language-bash\"># cd는 change directory의 줄임말입니다.\n# 방금 만든 프로젝트 폴더 안으로 이동합니다.\ncd &#x3C;내 깃허브 아이디>.github.io\n\n# package.json 파일에 적혀 있는 라이브러리들을 다운 받습니다.\n# svelte와 elder.js 등등의 모듈이 node_modules 폴더에 설치 됩니다.\n# yarn 을 사용한다면 yarn install도 가능합니다.\nnpm install\n\n# package.json에 있는 start 스크립트를 실행합니다.\n# dev 스크립트가 프로젝트를 빌드하고, 개발용 서버를 실행합니다.\nnpm start\n\n# 웹 브라우저에서 http://localhost:3000 으로 들어가면 사이트를 볼 수 있습니다.\nopen http://localhost:3000\n</code></pre>\n<p>정상적으로 프로젝트가 세팅이 되었다면, 웹 브라우저에서 다음과 같은 템플릿 사이트를 볼 수 있습니다.</p>\n<p><img src=\"https://res.cloudinary.com/practicaldev/image/fetch/s--A0xtvNLd--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/mksj4g4iuntzxkx5xdau.jpg\" alt=\"웹 브라우저에 Elder.js 템플릿 사이트가 열린 모습. Hello World: Welcome to Elder.js 라는 제목이 큰 글씨로 적혀 있다.\"></p>\n<p>개발용 localhost 서버는 내 컴퓨터에서만 볼 수 있습니다. 이제 저희 템플릿 프로젝트를 github pages에 올려서, 누구나 언제 어디서나 접속할 수 있게 만들어봅시다.</p>\n<p>영상이 편하신 분은 <a href=\"https://opentutorials.org/course/3084/18891\">생활코딩 WEBn 웹 호스팅</a> 강좌를 참고하세요. 약간 옛날 자료이긴 하지만 큰 개념을 잡는 데에는 무리가 없을 겁니다.</p>\n<h3 id=\"github-저장소-만들기\">github 저장소 만들기</h3>\n<p>깃허브에 가입하지 않으셨다면 먼저 <a href=\"https://github.com/signup\">회원가입</a>(Sign Up), 로그인(Sign In)을 해주세요.</p>\n<p>이제 저희 코드가 올라갈 클라우드 저장소(Repository)를 만들어야 합니다. 보통 줄여서 레포(Repo)라고도 부릅니다. 왼쪽 위에 보시면 다음과 같이 생긴 초록 버튼이 있습니다. 누르면 새 레포를 만드는 페이지가 나옵니다.</p>\n<p>{{githubNewRepoButton /}} 사실 이 버튼을 눌러도 바로 이동합니다.</p>\n<ol>\n<li>레포 이름은 앞서 정했던 <code>&#x3C;내 깃허브 아이디>.github.io</code> 로 합니다.</li>\n<li>Public과 Private가 있는데, Private로 하면 남들이 볼 수 없습니다. 사람들이 우리 사이트에 접속할 수 있게 하려면 Public을 선택합니다.</li>\n<li>README.md 파일이나 .gitignore 파일에 대해서는 다음 단계에서 설명합니다.</li>\n</ol>\n<p><img src=\"https://s3-ap-northeast-2.amazonaws.com/opentutorials-user-file/module/3135/7820.jpeg\" alt=\"깃허브 new repo 생성 페이지의 모습. repository name에 1, public/private 에 2, README 체크박스에 3이라는 번호가 적혀져 있다.\"></p>\n<h3 id=\"github-pages-설정하기\">github pages 설정하기</h3>\n<p>이제 저장소를 만들었으니, 저장소의 파일을 서빙하도록 설정해야 합니다.</p>\n<p>저장소 메뉴에 보면 Settings(설정)이 있습니다.\n<img src=\"https://docs.github.com/assets/images/help/repository/repo-actions-settings.png\" alt=\"Github 저장소 메뉴 사진. Settings 가 강조되어 있다.\"></p>\n<p>Pages 탭에 들어갑니다.</p>\n<p><img src=\"https://docs.github.com/assets/images/help/pages/pages-tab.png\" alt=\"설정의 메뉴 목록 사진. Pages가 강조되어 있다.\"></p>\n<p>Source 폴더를 <code>/(root)</code>에서 <code>/docs</code> 폴더로 바꾸고 저장(Save)해줍니다.</p>\n<p><img src=\"https://docs.github.com/assets/images/help/pages/publishing-source-folder-drop-down.png\" alt=\"source 폴더의 사진. 메뉴에 /root와 /docs가 있다.\"></p>\n<h3 id=\"gitignore로-용량이-큰-파일-보안에-민감한-파일-숨기기\">.gitignore로 용량이 큰 파일, 보안에 민감한 파일 숨기기</h3>\n<p>이제 아까 만들어둔 템플릿 프로젝트 폴더에 메모장이나 텍스트 에디터를 열고 <code>.gitignore</code> 라는 파일을 하나 만듭니다. txt 확장자로 저장하면 안 되고, 모든 파일 형식 으로 저장합니다.</p>\n<p>.gitignore에 적힌 파일이나 폴더는 remote 저장소에 올라가지 않게 됩니다. 저는 다음과 같이 3가지 폴더를 넣어주었습니다. 수정하고 저장합니다.</p>\n<ul>\n<li>node_modules는 용량이 크기 때문에</li>\n<li>___ELDER___는 컴파일된 중간 파일들이라서</li>\n<li>.env는 보안에 중요한 key 등이 들어가기 때문에 제외했습니다.</li>\n</ul>\n<pre><code class=\"language-text\"># .gitignore 파일 내용\n\nnode_modules\n___ELDER___\n.env\n</code></pre>\n<h3 id=\"nojekyll-파일-넣어서-asset-서빙되게-하기\">.nojekyll 파일 넣어서 asset 서빙되게 하기</h3>\n<p>Github Pages는 원래 Jekyll 이라는 루비 정적 사이트 생성기를 사용하는 게 기본입니다. 저희는 Elder.js 를 쓰기 때문에 .nojekyll 설정을 해줘야 합니다. 이 설정을 안 해주면 사이트 css나 이미지 같은 asset을 불러오지 못하게 됩니다. 디자인이 모두 날아간 황량한 HTML을 보지 않으려면...</p>\n<p>.nojekyll 파일을 만들어줍시다. 메모장으로 파일을 만들고 저장하면 됩니다. 내용은 비어 있어도 상관 없습니다.</p>\n<h3 id=\"배포되는-public-폴더-이름을-docs로-바꾸기\">배포되는 public 폴더 이름을 docs로 바꾸기</h3>\n<p>github pages는 root 폴더나 docs 라는 이름을 가진 폴더만 서빙할 수 있습니다. elder.js 는 기본적으로 public 폴더에 빌드된 html 파일들이 들어갑니다. 그렇기 때문에 설정을 바꿔서 docs 폴더에 들어가게 해줘야 합니다.</p>\n<p><code>elder.config.js</code> 파일을 텍스트 편집기로 열어보세요. 설정이 많지만 저희가 신경 쓸 건 딱 두 가지, 'origin'과 'distDir'입니다.</p>\n<p><code>origin</code>은 비어 있을 겁니다. 내 사이트의 host 도메인을 넣어줘야 하는데요. <code>https://&#x3C;내 깃허브 아이디>.github.io</code>를 적어주면 됩니다.</p>\n<p><code>distDir</code>은 <code>public</code>으로 되어 있을 겁니다. <code>docs</code> 로 바꿔줍니다.</p>\n<pre><code class=\"language-javascript\">module.exports = {\n  origin: 'https://&#x3C;내 깃허브 아이디>.github.io', // &#x3C;- 여기에 내 깃허브 pages 주소를 넣어줍니다.\n  lang: 'ko-KR',\n  srcDir: 'src',\n  distDir: 'docs', // &#x3C;- 여기를 docs로 바꿔 줍니다.\n  // 길어서 생략\n</code></pre>\n<h3 id=\"원격-저장소에-push-하기\">원격 저장소에 push 하기</h3>\n<p>이제 git으로 저희의 github 원격(remote) 저장소에 프로젝트를 올려보겠습니다. 혹시 빼먹고 넘어간 건 없는지 한 번 점검해보세요.</p>\n<p>문제가 없는 것 같다면 이제 터미널을 열고, 아까 저희가 만들어둔 템플릿 프로젝트 폴더로 이동합니다. cd 명령어를 이용하면 됩니다. 잘 모르겠다면 <a href=\"https://www.google.com/search?q=cd+%EB%AA%85%EB%A0%B9%EC%96%B4\">cd 명령어를 검색</a>해보세요</p>\n<p>이제 다음 명령어를 차례대로 실행합니다.</p>\n<pre><code class=\"language-bash\"># 현재 폴더를 깃 프로젝트로 설정합니다.\ngit init\n\n# 현재 폴더의 모든 파일을 git stage로 올려서 선택합니다.\ngit add .\n\n# stage에 선택된 파일들을 커밋해서 확정합니다.\ngit commit -m \"Initial commit\"\n\n# main 이라는 브랜치 버전을 만듭니다. \ngit branch -M main\n\n# 내 깃허브 원격 저장소를 추가해서 연결합니다.\ngit remote add origin https://github.com/&#x3C;내 깃허브 아이디>/&#x3C;내 깃허브 아이디>.github.io.git\n\n# 내 깃허브 원격 저장소에 커밋한 파일들을 올립니다!\ngit push -u origin main\n</code></pre>\n<p>성공적으로 push가 끝났으면, 내 github 페이지에 들어가서 파일이 잘 올라갔는지 확인합니다. 웹 브라우저 주소 창에 <code>https://&#x3C;내 깃허브 아이디>.github.io</code>를 치고 들어가면 됩니다.</p>\n<p>아까 localhost로 봤던 템플릿 사이트가 보이나요? 그러면 성공입니다!</p>\n<p>고생하셨습니다. 저희가 이번에 한 일을 정리해봅시다.</p>\n<ul>\n<li>Elder.js 템플릿 프로젝트를 세팅했습니다.</li>\n<li>템플릿 프로젝트를 Github 저장소에 올려서 배포했습니다.</li>\n</ul>\n<p>물론 이제 시작입니다. ;) 이제부터...</p>\n<ul>\n<li>블로그에 마크다운으로 글을 쓰는 방법</li>\n<li>내가 원하는대로 Layout, Home, Blog 의 디자인을 바꾸는 법</li>\n<li>다크모드, 날짜 순 정렬, 코드 문법 강조, Utterances 댓글 기능, 프로필 이미지 등을 넣는 법</li>\n<li>Elder.JS 의 작동 원리, 검색 엔진 최적화...</li>\n</ul>\n<p>그 밖에도 다양한 내용들을 차례차례 소개해보겠습니다. 궁금하신 게 있으면 댓글로 달아주세요.</p>","data":{"tocTree":[]},"permanlink":"/svelte-elder-create-blog/","tags":["Svelte","Elder.js","Github Pages","Blog"]}]};