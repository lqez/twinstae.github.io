export default {"blog_list":[{"slug":"development-environment-15minutes","frontmatter":{"title":"개발환경 구축 지도","excerpt":"개발환경을 구축하는데 필요한 다양한 개념들을 정리하고, 큰 그림을 그립니다.","date":"2021-07-14T10:11:26.973689","author":"탐정토끼(Taehee Kim)","tag":"작성 중, 개발환경"},"html":"<h2 id=\"지도를-챙기고-필요한만큼-배우자\">지도를 챙기고, 필요한만큼 배우자</h2>\n<h2 id=\"내가-이해할-수-있고-감당할-수-있나\">내가 이해할 수 있고 감당할 수 있나?</h2>\n<h2 id=\"작고-단순한-것부터-시작하자\">작고 단순한 것부터 시작하자</h2>\n<h2 id=\"가설을-세우고-실험으로-검증하기\">가설을 세우고 실험으로 검증하기</h2>\n<h2 id=\"일반적이고-보편적인-개념을-배우자\">일반적이고 보편적인 개념을 배우자</h2>\n<h2 id=\"프로그램을-어디에서도-실행하게-해주는-환경변수-path\">프로그램을 어디에서도 실행하게 해주는 환경변수 PATH</h2>\n<h2 id=\"운영체제와-cpu에-맞는-프로그램-설치하기\">운영체제와 CPU에 맞는 프로그램 설치하기</h2>\n<h2 id=\"사용하는-버전-확인하기\">사용하는 버전 확인하기</h2>\n<p>Breaking Change</p>\n<h2 id=\"명령줄-command-line\">명령줄 Command Line</h2>\n<h2 id=\"컴파일러-인터프리터-런타임\">컴파일러, 인터프리터, 런타임</h2>\n<h3 id=\"gcc-리눅스-진영의-c-컴파일러\">GCC: 리눅스 진영의 C 컴파일러</h3>\n<h3 id=\"javac-자바-컴파일러\">javac: 자바 컴파일러</h3>\n<h3 id=\"cpython-파이썬-공식-인터프리터-구현체\">CPython: 파이썬 공식 인터프리터 구현체</h3>\n<h4 id=\"pypy\">PyPy</h4>\n<h3 id=\"node-js-런타임\">Node: js 런타임</h3>\n<h4 id=\"deno-rust로-다시-만든-jsts-런타임\">Deno: Rust로 다시 만든 Js/Ts 런타임</h4>\n<h3 id=\"babel-모던-자바스크립트를-위한-트랜스파일러\">Babel: 모던 자바스크립트를 위한 트랜스파일러</h3>\n<h3 id=\"tsc-타입스크립트-트랜스파일러\">TSC: 타입스크립트 트랜스파일러</h3>\n<h2 id=\"repl-console-명령줄에서-코드-실험하기\">Repl, Console: 명령줄에서 코드 실험하기</h2>\n<h3 id=\"python\">Python</h3>\n<h3 id=\"브라우저-개발자-도구-console\">브라우저 개발자 도구 Console</h3>\n<h2 id=\"빌드-패키지-의존성-관리-도구\">빌드, 패키지, 의존성 관리 도구</h2>\n<h3 id=\"gradle-java-패키지-관리-빌드-도구\">gradle: Java 패키지 관리, 빌드 도구</h3>\n<h3 id=\"npm-yarn-js-패키지-관리-도구\">npm, yarn: js 패키지 관리 도구</h3>\n<h3 id=\"webpack-rollup-vite-js-모듈-번들러\">webpack, rollup, vite: js 모듈 번들러</h3>\n<h3 id=\"pip-파이썬-기본-패키지-관리-도구\">pip: 파이썬 기본 패키지 관리 도구</h3>\n<h3 id=\"poetry-현대적인-파이썬-패키지-관리-도구\">poetry: 현대적인 파이썬 패키지 관리 도구</h3>\n<h3 id=\"apt-get-우분투-리눅스-패키지-관리-도구\">apt-get: 우분투 리눅스 패키지 관리 도구</h3>\n<h2 id=\"curl-wget-인터넷에서-파일-다운-받기\">curl, wget: 인터넷에서 파일 다운 받기</h2>\n<h2 id=\"sh-쉘-스크립트\">sh: 쉘 스크립트</h2>\n<h2 id=\"프로젝트-템플릿\">프로젝트 템플릿</h2>\n<h2 id=\"프레임워크-라이브러리-모듈\">프레임워크, 라이브러리, 모듈</h2>\n<h2 id=\"서로-다른-프로젝트-간에-버전-관리하기\">서로 다른 프로젝트 간에 버전 관리하기</h2>\n<h2 id=\"docker-개발환경을-컨테이너-째로-다운-받으세요\">Docker: 개발환경을 컨테이너 째로 다운 받으세요.</h2>\n<h2 id=\"각종-설정-config-파일\">각종 설정 config 파일</h2>\n<h2 id=\"텍스트-편집기\">텍스트 편집기</h2>\n<h3 id=\"vs-code-오픈소스-텍스트-에디터-플러그인-생태계\">VS Code: 오픈소스 텍스트 에디터, 플러그인 생태계</h3>\n<h3 id=\"jetbrain-똑똑한-통합-개발-환경\">JetBrain: 똑똑한 통합 개발 환경</h3>\n<h3 id=\"vim-강력한-단축키-커맨드-라인-최적화\">Vim: 강력한 단축키, 커맨드 라인 최적화</h3>\n<h3 id=\"그-외-emacs-sublime-text-notepad-메모장\">그 외: Emacs, Sublime Text, Notepad++, 메모장...</h3>\n<h2 id=\"문법-검사와-lsp\">문법 검사와 LSP</h2>\n<h2 id=\"git-프로젝트-버전-관리\">Git: 프로젝트 버전 관리</h2>\n<h2 id=\"배포-자동화\">배포 자동화</h2>\n<h3 id=\"github-action\">Github Action</h3>\n<h3 id=\"jenkins\">Jenkins</h3>\n<h2 id=\"브라우저-에뮬레이터\">브라우저, 에뮬레이터</h2>\n<h2 id=\"테스트-도구\">테스트 도구</h2>","data":{"tocTree":[]},"permanlink":"/development-environment-15minutes/","tags":["작성 중","개발환경"]},{"slug":"persistence-layer","frontmatter":{"title":"영속성 계층","excerpt":"영속성 계층은 프로그램의 상태와 데이터를 관리, 저장, 복원합니다. 파일부터 데이터베이스, DDD의 레포지토리 패턴도 소개합니다.","date":"2021-07-13T19:44:17.038983","author":"탐정토끼(Taehee Kim)","tag":"작성 중, DDD, 계층형 아키텍처, 영속성, 파일, 데이터베이스, 레포지토리 패턴"},"html":"<h2 id=\"영속성은-프로그램이-종료되어도-상태를-유지하고-다시-불러올-수-있게-합니다\">영속성은 프로그램이 종료되어도 상태를 유지하고, 다시 불러올 수 있게 합니다.</h2>\n<h2 id=\"파일-시스템\">파일 시스템</h2>\n<h2 id=\"데이터베이스\">데이터베이스</h2>\n<h3 id=\"sql-관계형-데이터-베이스\">SQL 관계형 데이터 베이스</h3>\n<h4 id=\"orm-객체-관계-맵핑\">ORM 객체 관계 맵핑</h4>\n<h4 id=\"두-개의-모자\">두 개의 모자</h4>\n<h3 id=\"nosql\">NoSQL</h3>\n<h4 id=\"key-value\">Key-Value</h4>\n<h4 id=\"document\">Document</h4>\n<h4 id=\"graph\">Graph</h4>\n<h4 id=\"search-engine\">Search Engine</h4>\n<h2 id=\"repository-pattern\">Repository Pattern</h2>","data":{"tocTree":[]},"permanlink":"/persistence-layer/","tags":["작성 중","DDD","계층형 아키텍처","영속성","파일","데이터베이스","레포지토리 패턴"]},{"slug":"api-layer","frontmatter":{"title":"API 계층","excerpt":"REST, gRPC, GraphQL, Socket, PubSub 등등... API 계층은 외부에서 들어온 요청을 작업으로 변환하고, 결과를 응답으로 변환하고 전달합니다.","date":"2021-07-13T18:30:36.653907","author":"탐정토끼(Taehee Kim)","tag":"작성 중, DDD, 계층형 아키텍처, API, REST, gRPC, GraphQL, WebSocket, PubSub"},"html":"<h2 id=\"api는-서버가-외부와-통신하는-방법이자-계약입니다\">API는 서버가 외부와 통신하는 방법이자, 계약입니다.</h2>\n<h2 id=\"수단과-양식-통신-프로토콜\">수단과 양식, 통신 프로토콜</h2>\n<h3 id=\"http-hypertext-transfer-protocol-하이퍼-텍스트-전송-규약\">HTTP: HyperText Transfer Protocol 하이퍼 텍스트 전송 규약</h3>\n<blockquote>\n<p>Hypertext Transfer Protocol (HTTP) is an application-layer protocol for transmitting hypermedia documents, such as HTML. It was designed for communication between web browsers and web servers, but it can also be used for other purposes. HTTP follows a classical client-server model, with a client opening a connection to make a request, then waiting until it receives a response. HTTP is a stateless protocol, meaning that the server does not keep any data (state) between two requests. Though often based on a TCP/IP layer, it can be used on any reliable transport layer, that is, a protocol that doesn't lose messages silently like UDP does. RUDP — the reliable update of UDP — is a suitable alternative.</p>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/HTTP\">MDN HTTP 문서</a></p>\n</blockquote>\n<blockquote>\n<p>The Hypertext Transfer Protocol (HTTP) is an application-level protocol for distributed, collaborative, hypermedia information systems. It is a generic, stateless, protocol which can be used for many tasks beyond its use for hypertext, such as name servers and distributed object management systems, through extension of its request methods, error codes and headers [47]. A feature of HTTP is the typing and negotiation of data representation, allowing systems to be built independently of the data being transferred.</p>\n<p><a href=\"https://datatracker.ietf.org/doc/html/rfc2616\">RFC2616 Hypertext Transfer Protocol -- HTTP/1.1 스펙</a></p>\n</blockquote>\n<h4 id=\"restful-representational-state-transfer-표현적-상태-전이\">RESTful: Representational state transfer 표현적 상태 전이</h4>\n<blockquote>\n<p>Client-Server, Stateless, Cache, Uniform Interface, Layered System</p>\n<p>Roy Thomas Fielding의 논문</p>\n<p><a href=\"https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm\">Architectural Styles and the Design of Network-based Software Architectures</a></p>\n</blockquote>\n<h4 id=\"openapi\">OpenAPI</h4>\n<blockquote>\n<p>The OpenAPI Specification (OAS) defines a standard, language-agnostic interface to RESTful APIs which allows both humans and computers to discover and understand the capabilities of the service without access to source code, documentation, or through network traffic inspection. When properly defined, a consumer can understand and interact with the remote service with a minimal amount of implementation logic.\nAn OpenAPI definition can then be used by documentation generation tools to display the API, code generation tools to generate servers and clients in various programming languages, testing tools, and many other use cases.</p>\n<p><a href=\"https://swagger.io/specification/\">Swagger 공식 사이트의 OpenAPI 소개</a></p>\n</blockquote>\n<h4 id=\"동사로-api만들기-rest를-넘어서\">동사로 API만들기: REST를 넘어서</h4>\n<h3 id=\"grpc-google-remote-procedure-call-구글-원격-프로시저-호출\">gRPC: google Remote Procedure Call 구글 원격 프로시저 호출</h3>\n<blockquote>\n<p>gRPC is a modern open source high performance Remote Procedure Call (RPC) framework that can run in any environment. It can efficiently connect services in and across data centers with pluggable support for load balancing, tracing, health checking and authentication. It is also applicable in last mile of distributed computing to connect devices, mobile applications and browsers to backend services.</p>\n<p><a href=\"https://grpc.io/about/\">About gRPC 공식 홈페이지</a></p>\n</blockquote>\n<h3 id=\"graphql-graph-query-language-진화하는-api를-위한-질의-언어\">GraphQL: Graph Query Language 진화하는 API를 위한 질의 언어</h3>\n<blockquote>\n<p>GraphQL is a query language for APIs and a runtime for fulfilling those queries with your existing data. GraphQL provides a complete and understandable description of the data in your API, gives clients the power to ask for exactly what they need and nothing more, makes it easier to evolve APIs over time, and enables powerful developer tools.</p>\n<p><a href=\"https://graphql.org/\">GraphQL 공식 사이트</a></p>\n</blockquote>\n<h3 id=\"websocket-양방향-실시간-이벤트-기반-통신을-위한-api\">WebSocket: 양방향, 실시간, 이벤트 기반 통신을 위한 API</h3>\n<blockquote>\n<p>The WebSocket API is an advanced technology that makes it possible to open a two-way interactive communication session between the user's browser and a server. With this API, you can send messages to a server and receive event-driven responses without having to poll the server for a reply.</p>\n<p><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API\">MDN The WebSocket API 문서</a></p>\n</blockquote>\n<blockquote>\n<p>Socket.IO enables real-time, bidirectional and event-based communication.\nIt works on every platform, browser or device, focusing equally on reliability and speed.</p>\n<p>대표적인 소켓 통신 라이브러리. <a href=\"https://socket.io/\">Socket.IO 공식 사이트</a></p>\n</blockquote>\n<h3 id=\"pubsub-게시자-구독자-패턴-비동기-메세징-api\">PubSub: 게시자-구독자 패턴. 비동기 메세징 API</h3>\n<blockquote>\n<p>SUBSCRIBE, UNSUBSCRIBE and PUBLISH implement the Publish/Subscribe messaging paradigm where (citing Wikipedia) senders (publishers) are not programmed to send their messages to specific receivers (subscribers). Rather, published messages are characterized into channels, without knowledge of what (if any) subscribers there may be.\nSubscribers express interest in one or more channels, and only receive messages that are of interest, without knowledge of what (if any) publishers there are. This decoupling of publishers and subscribers can allow for greater scalability and a more dynamic network topology.</p>\n<p><a href=\"https://redis.io/topics/pubsub\">Redis Pub/Sub 공식 문서</a></p>\n</blockquote>","data":{"tocTree":[]},"permanlink":"/api-layer/","tags":["작성 중","DDD","계층형 아키텍처","API","REST","gRPC","GraphQL","WebSocket","PubSub"]},{"slug":"python-async-db","frontmatter":{"title":"파이썬 비동기 DB 비교 - 1. 큰 그림","excerpt":"파이썬에서 비동기 DB를 SQLDriver, ORM, NoSQL까지 다양한 방법으로 구현해보고 비교해보려 합니다. 큰 그림을 그려보면서 시작합니다.","date":"2021-07-13T11:23:44.765012","author":"탐정토끼(Taehee Kim)","tag":"작성 중, 비동기, 파이썬, 데이터베이스"},"html":"<h2 id=\"asyncio-db를-다양한-방식으로-구현해보고-비교합니다\">AsyncIO DB를 다양한 방식으로 구현해보고 비교합니다.</h2>\n<h2 id=\"비동기는-쓰레드-하나single-thread로도-차단blocking-없이-더-많은-요청을-처리할-수-있습니다\">비동기는 쓰레드 하나(single thread)로도 차단(Blocking) 없이 더 많은 요청을 처리할 수 있습니다.</h2>\n<h2 id=\"파이썬에서는-asyncio와-asyncawait-키워드로-비동기를-처리합니다\">파이썬에서는 AsyncIO와 async/await 키워드로 비동기를 처리합니다.</h2>\n<h2 id=\"다양한-db를-사용해서-구현해보고-비교해봅니다\">다양한 DB를 사용해서 구현해보고 비교해봅니다.</h2>\n<h3 id=\"sql-driver--sqliteaiosqlite-postgresqlasyncpg\">SQL Driver : SQLite/aiosqlite, PostgreSQL/asyncpg</h3>\n<h3 id=\"orm-객체-관계-맵퍼--sqlalchemy-tortoise\">ORM 객체 관계 맵퍼 : SQLAlchemy, Tortoise</h3>\n<h3 id=\"next-generation--edgedb\">Next-Generation? : EdgeDB</h3>\n<h3 id=\"key-value-키-값--redisasync-redis\">Key-Value 키-값 : Redis/async-redis</h3>\n<h3 id=\"document--mongodbmotor\">Document : MongoDB/Motor</h3>\n<h3 id=\"graph--neo4jaioneo4j\">Graph : Neo4j/aioneo4j</h3>","data":{"tocTree":[]},"permanlink":"/python-async-db/","tags":["작성 중","비동기","파이썬","데이터베이스"]},{"slug":"what-is-asynchronous","frontmatter":{"title":"비동기(asynchronous)","excerpt":"비동기는 DB나 네트워크 요청 등을 차단 없이 처리할 수 있습니다. 개념을 설명하고, 흔한 오해를 풀어봅니다.","date":"2021-07-13T11:22:34.832910","author":"탐정토끼(Taehee Kim)","tag":"작성 중, 비동기, 동시성, 병렬성, Blocking"},"html":"","data":{"tocTree":[]},"permanlink":"/what-is-asynchronous/","tags":["작성 중","비동기","동시성","병렬성","Blocking"]},{"slug":"hljs-elder-blog","frontmatter":{"title":"highlight.js로 코드블럭 문법 강조하기","excerpt":"Elder.js 기본 템플릿에 highlight.js를 이용해서 코드블럭 문법 강조(syntax highlight)를 넣어봅시다.","date":"2021-07-11T13:27:22.262492","author":"탐정토끼(Taehee Kim)","tag":"작성 중, Elder.js, Blog, syntax highlighting"},"html":"<h2 id=\"higliightjs\">higliight.js</h2>","data":{"tocTree":[]},"permanlink":"/hljs-elder-blog/","tags":["작성 중","Elder.js","Blog","syntax highlighting"]},{"slug":"category-for-functional","frontmatter":{"title":"함수형 프로그래밍을 위한 카테고리 이론","excerpt":"수학까지 해야하나? 함수형 프로그래밍의 근간이 되는 카테고리 이론과 학습 자료를 소개합니다.","date":"2021-07-10T10:03:01.321Z","author":"탐정토끼(Taehee Kim)","tag":"작성 중, 함수형, 카테고리 이론"},"html":"<p>latex 테스트</p>\n<p>함수 합성</p>\n<p>ℎ ∘ (𝑔 ∘ 𝑓 ) = (ℎ ∘ 𝑔) ∘ 𝑓 = ℎ ∘ 𝑔 ∘ 𝑓</p>\n<h2 id=\"remark-math-katex\">remark math katex</h2>\n<div class=\"math math-display\"><span class=\"katex-display\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mi>h</mi><mo>∘</mo><mo stretchy=\"false\">(</mo><mi>g</mi><mo>∘</mo><mi>f</mi><mo stretchy=\"false\">)</mo><mo>=</mo><mo stretchy=\"false\">(</mo><mi>h</mi><mo>∘</mo><mi>g</mi><mo stretchy=\"false\">)</mo><mo>∘</mo><mi>f</mi><mo>=</mo><mi>h</mi><mo>∘</mo><mi>g</mi><mo>∘</mo><mi>f</mi></mrow><annotation encoding=\"application/x-tex\">h \\\\circ (g \\\\circ f) = (h \\\\circ g) \\\\circ f = h \\\\circ g \\\\circ f</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">h</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∘</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∘</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord mathnormal\">h</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∘</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mclose\">)</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∘</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.69444em;vertical-align:0em;\"></span><span class=\"mord mathnormal\">h</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∘</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.63889em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">g</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">∘</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.8888799999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.10764em;\">f</span></span></span></span></span></div>","data":{"tocTree":[]},"permanlink":"/category-for-functional/","tags":["작성 중","함수형","카테고리 이론"]},{"slug":"string-std","frontmatter":{"title":"언어들이 문자열 String을 다루는 방식","excerpt":"Java, JS, Python, Rust, Clojure, Elixir 등등 다양한 언어들이 문자열을 다루는 방식을 비교하고 익혀봅니다.","date":"2021-07-08T15:26:07.156Z","author":"탐정토끼(Taehee Kim)","tag":"작성 중, std, 프로그래밍 언어"},"html":"<h2 id=\"언어-사이에-공통점과-차이점\">언어 사이에 공통점과 차이점</h2>\n<h3 id=\"문자열은-무엇인가\">문자열은 무엇인가?</h3>\n<h3 id=\"문자열-인코딩은-utf-8인가\">문자열 인코딩은 UTF-8인가?</h3>\n<h3 id=\"원시타입인가-객체인가\">원시타입인가 객체인가?</h3>\n<h3 id=\"char와-string을-구분하는가\">Char와 String을 구분하는가?</h3>\n<h3 id=\"자동-형변환이-가능한가\">자동 형변환이 가능한가?</h3>\n<h3 id=\"메서드인가-모듈-함수인가\">메서드인가, 모듈 함수인가?</h3>\n<h3 id=\"인덱스가-0부터-시작하는가\">인덱스가 0부터 시작하는가?</h3>\n<p>포트란, Lua, Julia</p>\n<h3 id=\"인덱스-슬라이싱이-가능한가\">인덱스 슬라이싱이 가능한가?</h3>\n<h3 id=\"인덱스-for-vs-iterator\">인덱스 for vs Iterator</h3>\n<h3 id=\"정규표현식\">정규표현식</h3>\n<h2 id=\"프로그래밍-언어별-string-코드-예시\">프로그래밍 언어별 String 코드 예시</h2>\n<h3 id=\"java-char-char-string\">Java: char, Char, String</h3>\n<pre><code class=\"language-java\">String foo = \"abcde\";\nStringBuffer sb = new StringBuffer(str);\nString reversedFoo = sb.reverse().toString();\nSystem.out.println(reversedFoo);\n</code></pre>\n<h3 id=\"python-str\">Python: str</h3>\n<pre><code class=\"language-python\">foo = \"탐정토끼\" # 리터럴\nassert type(foo) == type(\"탐\") # 글자 하나의 타입도 string이다.\n# &#x3C;class 'str'>\n\nassert len(foo) == 4 # 문자열의 길이\n\n# 문자열[start : end : step]\nassert foo[0] == \"탐\"  # 문자 가져오기\nassert foo[1:] == \"정토끼\" # 자르기. start 부터 끝까지\nassert foo[1:3] == \"정토\"  # 마지막 인덱스는 미포함\nassert foo[-2:] == \"토끼\"  # 마지막 2글자\nassert \"abcdefg\"[::2] == \"aceg\" # step 2칸씩 \n\nprint(foo[::-1]) # 뒤집기\n# \"끼토정탐\"\n\nassert \"2014/02/14\".replace(\"/\", \"-\") == \"2014-02-14\" # 치환\nassert \"2014/02/14\".split(\"/\") == [\"2014\", \"02\", \"14\"] # 쪼개기\n\nassert str(24) + \"시간이 모자라\" # int와 문자열 합치기\n# \"24시간이 모자라\"\nassert \"1\" &#x3C; \"3\" # 비교 가능\n\nassert \"taehee\" + \" \" + \"kim\" == \"taehee kim\" # 합치기\nassert \"\".join([\"탐정\", \"토끼\", \"입니다.\"]) == \"탐정토끼입니다.\" # 붙이기\n\nlong_csv = \"\"\"12, 3, \"빨강\"\n13, 2, \"파랑\"\n14, 1, \"초록\"\n\"\"\" # 여러 줄 문자열\nlong_csv.split(\"\\\n\") # 줄 단위로 자르기\n\nassert \"탐정\" in foo == True # foo가 \"탐정\"을 포함하는지? \nassert \"https://twinstae.github.io/\".startswith(\"https\") == True # 시작하는지?\nassert \"fiesta-izone.mp3\".endswith(\".mps\") # 끝나는지?\n\nname: str = 'kim' # 타입힌트, ' 홑 따옴표도 상관 없다.\n\nassert not name == True;   # 비어 있는지? PEP8 가이드 권장\n# \"name != \"\"               # 이렇게 할 수도 있긴 하다.\n\nprint('hello, %s' % name) # format\n# 'hello, kim'\nprint(f'hello, {name}')   # interpolation\n# 'hello, kim'\n\nprint('TAEhee Kim'.lower()) # 소문자로\n# 'taehee kim'\n'    내용     \\\n   '.strip()  # 공백 자르기\n# '내용'\n\nm = re.search('([1-6])학년 ([0-9]{1,2})단원', '2학년 3단원')\nassert m.group(0) == '2학년 3단원'\nassert m.group(1) == '2'\nassert m.group(2) == '3'\n</code></pre>\n<h3 id=\"typescript-string\">TypeScript: string</h3>\n<pre><code class=\"language-typescript\">const foo: string = \"탐정토끼\";\nconsole.log(foo.split(\"\").reverse().join());\n</code></pre>\n<h3 id=\"rust-str-stdstring\">Rust: str, std::String</h3>\n<pre><code class=\"language-rust\">let foo = \"탐정토끼\";\nprintln!(\"{}\", foo.chars().rev().collect::&#x3C;String>());\n</code></pre>\n<h3 id=\"clojure-javalangcharacter-javalangstring\">Clojure: java.lang.Character, java.lang.String</h3>\n<pre><code class=\"language-clojure\">(require '[clojure.string :as s])\n(def foo \"탐정토끼\")\n\n(count foo) ; 길이\n; 4\n\n(get foo 0) ; 문자 가져오기\n; \\\\탐\n(subs foo 1) ; 자르기. start 부터 끝까지\n;\"정토끼\"\n(subs foo 1 3) ; 마지막 인덱스는 미포함\n;\"정토\"\n(subs foo (- (count foo) 2)) ; 마지막 2글자\n;\"토끼\"\n\n(print (s/reverse foo)) ; 뒤집기\n\n(s/replace \"2014/02/14\" \"/\", \"-\") ; 바꾸기\n; \"2014-02-14\"\n(s/split \"2014/02/14\" \"/\") ; 쪼개기\n; (\"2014\" \"02\" \"14\")\n\n(def long-csv \"12, 3, \\\\\"빨강\\\\\"\n13, 2, \\\\\"파랑\\\\\"\n14, 1, \\\\\"초록\\\\\"\n\")\n(s/split-lines long-csv)\n\n(s/includes? foo \"탐정\") ; foo가 \"탐정\"을 포함하는지?\n(s/startswith? \"https://twinstae.github.io/\" \"https\") ; 시작하는지?\n(s/ends-with? \"fiesta-izone.mp3\" \".mp3\") ; 끝나는지?\n\n(s/blank? foo) ; 비어있는지?\n\n(str \"taehee\" \" \" \"kim\") ; 합치기\n; \"taehee kim\"\n(str 24 \"시간이 모자라\") ; int와 문자열 합치기. 자동 형 변환.\n; \"24시간이 모자라\"\n\n; (&#x3C; \"1\" \"3\")\n; 비교 불가 .String cannot be cast to class java.lang.Number\n\n(s/join \" \" [\"탐정\" \"토끼\" \"입니다.\"]) ; 붙이기\n; \"탐정 토끼 입니다.\"\n\n(format \"hello, %s\" foo) ; 포맷\n; \"hello, 탐정토끼\"\n\n(s/lower \"TAEhee Kim\")\n; \"taehee kim\"\n(s/trim \"    내용     \\\n   \")\n; \"내용\"\n</code></pre>\n<h3 id=\"elixir-stringgrapheme-stringt\">Elixir: String.grapheme(), String.t()</h3>\n<pre><code class=\"language-elixir\">foo = \"탐정토끼\"\nIO.puts String.reverse(foo)\n</code></pre>","data":{"tocTree":[]},"permanlink":"/string-std/","tags":["작성 중","std","프로그래밍 언어"]},{"slug":"brief-history-of-web-front","frontmatter":{"title":"웹 프런트 엔드의 간략한 역사","excerpt":"태초의 HTML 정적 파일부터, 템플릿 엔진, CSR, SPA, SSR, JAM Stack 에 이르기까지 웹 프런트 엔드가 진화해온 과정","date":"2021-07-08T07:30:58.196Z","author":"탐정토끼(Taehee Kim)","tag":"작성 중, front-end, CSR, SPA, SSR, JAM Stack"},"html":"<h2 id=\"static-file-정적-파일을-서빙하기---나모-웹-에디터\">Static File 정적 파일을 서빙하기 - 나모 웹 에디터</h2>\n<p>{{keyword}}Static File{{/keyword}} 을 서빙하기</p>\n<h3 id=\"웹-브라우저-주소-창에-url을-치면-일어나는-일\">웹 브라우저 주소 창에 URL을 치면 일어나는 일</h3>\n<h3 id=\"정적-파일static-file-html-css-js-이미지\">정적 파일(static file) HTML, CSS, JS, 이미지</h3>\n<h3 id=\"url과-폴더-기반-라우팅\">url과 폴더 기반 라우팅</h3>\n<h2 id=\"ssr-서버에서-템플릿-동적으로-렌더링하기---템플릿-엔진\">SSR 서버에서 템플릿 동적으로 렌더링하기 - 템플릿 엔진</h2>\n<p>{{keyword}}SSR{{/keyword}}이란...</p>\n<h3 id=\"실시간으로-변하는-상태state에-따라-다른-내용을-보여주고-싶다\">실시간으로 변하는 상태(state)에 따라 다른 내용을 보여주고 싶다.</h3>\n<h3 id=\"동적-dynamic-렌더링이란\">동적 (dynamic) 렌더링이란?</h3>\n<h2 id=\"csr-클라이언트에서-렌더링하기---jquery와-ajax-모던-js\">CSR 클라이언트에서 렌더링하기 - JQuery와 Ajax, 모던 JS</h2>\n<h3 id=\"사용자-동작에-따라-반응하게-만들고-싶다\">사용자 동작에 따라 반응하게 만들고 싶다.</h3>\n<h2 id=\"spa-웹-앱을-만들자---angular-vue-react\">SPA 웹 앱을 만들자 - Angular, Vue, React</h2>\n<h3 id=\"새로고침-없이-브라우저에서-동적으로-dom을-그리고-싶다\">새로고침 없이 브라우저에서 동적으로 dom을 그리고 싶다.</h3>\n<h2 id=\"ssr이-spa와-함께-부활하다---nextjs\">SSR이 SPA와 함께 부활하다 - Next.js</h2>\n<h3 id=\"빠르게-사이트를-보여주고-멍청한-검색엔진-크롤러에게-html을-보여주고-싶다\">빠르게 사이트를 보여주고, 멍청한 검색엔진 크롤러에게 HTML을 보여주고 싶다</h3>\n<h2 id=\"정적-파일이-현대-기술과-함께-돌아오다---jam\">정적 파일이 현대 기술과 함께 돌아오다 - JAM</h2>\n<h3 id=\"복잡한-webserver-없이-빠르게-웹-사이트를-보여주고-싶다\">복잡한 WebServer 없이 빠르게 웹 사이트를 보여주고 싶다.</h3>\n<blockquote>\n<ul>\n<li><a href=\"https://jamstack.org/\">잼스택 홍보 사이트</a></li>\n<li><a href=\"https://www.itworld.co.kr/news/156752\">잼스택, 웹 개발을 뒤집는 정적 웹사이트 혁명 : IT World 번역 기사</a></li>\n<li><a href=\"https://pks2974.medium.com/jam-stack-%EA%B0%9C%EB%85%90-%EC%A0%95%EB%A6%AC%ED%95%98%EA%B8%B0-17dd5c34edf7\">JAM Stack 개념 정리하기 : 박성룡님 블로그</a></li>\n</ul>\n</blockquote>\n<h2 id=\"진화는-일직선이-아니다\">진화는 일직선이 아니다.</h2>\n<h2 id=\"각-방식의-장-단점-총-정리\">각 방식의 장, 단점 총 정리</h2>","data":{"tocTree":[]},"permanlink":"/brief-history-of-web-front/","tags":["작성 중","front-end","CSR","SPA","SSR","JAM Stack"]},{"slug":"what-is-trade-off","frontmatter":{"title":"Trade Off 트레이드 오프","excerpt":"Trade Off란 교환 관계에 있다는 뜻이다. 즉 어떤 언어나 기술을 선택했을 때 얻는 게 있으면, 잃는 것도 있다는 뜻으로 쓴다.","date":"2021-07-08T07:20:00.196Z","author":"탐정토끼(Taehee Kim)","tag":"작성 중, 개념어, Trade Off"},"html":"<p>사전적 정의 : 교환, 마치 양팔 저울처럼 한 쪽을 늘리면, 다른 한 쪽을 잃게 된다는 뜻.\n여러 언어나 기술에는 각자 장, 단점이 있으니 내 상황에 맞게 올바른 기술을 선택해야한다는 뜻으로 쓰입니다.</p>","data":{"tocTree":[]},"permanlink":"/what-is-trade-off/","tags":["작성 중","개념어","Trade Off"]},{"slug":"customize-elder-blog","frontmatter":{"title":"Elder 블로그 커스터마이징 하기","excerpt":"Elder 기본 템플릿에 웹 폰트, 날짜 순 정렬, tooltip 같은 기능들을 추가해봅니다.","date":"2021-07-08T05:01:27.798Z","author":"탐정토끼(Taehee Kim)","tag":"작성 중, Svelte, Elder.js, Blog"},"html":"<h2 id=\"elder-블로그-템플릿-프로젝트-구조-살펴보기\">Elder 블로그 템플릿 프로젝트 구조 살펴보기</h2>\n<h2 id=\"noto-sans-nanum-웹-폰트-적용하기\">Noto Sans, Nanum 웹 폰트 적용하기</h2>\n<h2 id=\"게시글-목록-날짜-순으로-정렬하기\">게시글 목록 날짜 순으로 정렬하기</h2>\n<h2 id=\"게시글-목록에-날짜-달기\">게시글 목록에 날짜 달기</h2>\n<h2 id=\"게시글-목록-페이지네이션\">게시글 목록 페이지네이션</h2>\n<h2 id=\"다크모드-테마-지원하기\">다크모드 테마 지원하기</h2>","data":{"tocTree":[]},"permanlink":"/customize-elder-blog/","tags":["작성 중","Svelte","Elder.js","Blog"]},{"slug":"svelte-elder-create-blog","frontmatter":{"title":"Svelte Elder.js 블로그 만들기","excerpt":"검색 엔진 최적화(SEO)된 Svelte 정적 페이지 생성기인 ElderJS로 블로그 만드는 과정을 설명합니다.","date":"2021-07-07T15:01:00.618Z","author":"탐정토끼(Taehee Kim)","tag":"Svelte, Elder.js, Github Pages, Blog"},"html":"<p>이 블로그는 <a href=\"https://svelte.dev/\">Svelte</a>와 <a href=\"https://elderguide.com/tech/elderjs/\">Elder.js</a>로 만들었습니다. 이 글에서는 여러분에게 Svelte와 Elder.js를 소개하고, 여러분도 비슷한 블로그를 만들 수 있게 도와드리려 합니다.</p>\n<h2 id=\"필요한-것--html-css-js--nodejs-설치--github-계정\">필요한 것 : HTML, CSS, JS / Node.js 설치 / GitHub 계정</h2>\n<p>제 블로그는 초보도 쉽게 따라할 수 있도록 자세하고 친절하게 쓰려 합니다. 이미 많이 알고 계시는 분들은 큰 제목 위주로 빠르게 읽어 내려가시면 되겠습니다.</p>\n<ul>\n<li>HTML, CSS, JS에 대해 기본적인 지식이 있어야합니다.\n<ul>\n<li>잘 모른다면 <a href=\"https://opentutorials.org/course/3083\">생활코딩 WEBn</a> 강좌로 시작하길 권해드립니다.</li>\n</ul>\n</li>\n<li><a href=\"https://nodejs.org/ko/download/\">Node.JS</a>가 설치되어 있고, NPM 을 사용할 수 있어야 합니다.\n<ul>\n<li><a href=\"https://opentutorials.org/course/3332/21029\">생활코딩 Node.js 설치</a> 강의 영상을 참고하세요.</li>\n</ul>\n</li>\n<li>GitHub 계정이 있고, Git을 사용할 줄 알아야 합니다.\n<ul>\n<li><a href=\"https://opentutorials.org/course/3837\">생활코딩 GIT1</a>, <a href=\"https://opentutorials.org/course/307/2475\">생활코딩 GitHub</a> 강좌도 있습니다. (없는 게 없네요!)</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"이론--svelte-와-elderjs-를-소개합니다\">이론 : Svelte 와 Elder.js 를 소개합니다.</h2>\n<p>이 두 친구와 {{keyword}}SEO{{/keyword}}, {{keyword}}JAM Stack{{/keyword}} 등에 대해 이미 잘 알고 계신다면 바로 실전으로 넘어가셔도 됩니다.</p>\n<h3 id=\"svelte는-가상-돔-없이-바닐라js에-가깝게-개발할-수-있는-웹-프레임워크입니다\">Svelte는 가상 돔 없이 바닐라JS에 가깝게 개발할 수 있는 웹 프레임워크입니다.</h3>\n<p><img src=\"https://camo.githubusercontent.com/c0334ff12149f79bcf27d97aca688ddb72c989c09c3f6b9db0a93d59cb1bbc28/68747470733a2f2f7376656c74656a732e6769746875622e696f2f6173736574732f62616e6e65722e706e67\" alt=\"Svelte 로고가 들어간 배너\"></p>\n<blockquote>\n<p>출처 : Svelte 깃허브 배너</p>\n</blockquote>\n<p>Svelte는 요즘 유명해졌습니다. Angular, React, Vue 3대장을 이은 다크호스로 주목 받고 있죠. 물론 Svelte가 뭔지 모르시는 분도 있을 겁니다.</p>\n<p>Svelte가 도대체 뭐길래? 공식 홈페이지에서는 다음 3가지 특징을 밀고 있습니다.</p>\n<ul>\n<li>Write less code : HTML, CSS, {{keyword}}바닐라JS{{/keyword}}에 가깝게 코딩할 수 있고요. 복잡한 보일러 플레이트가 거의 없습니다.</li>\n<li>No virtual DOM : 가상 돔 같은 프레임워크 오버헤드 없이, 가벼운 바닐라 JS 코드로 컴파일됩니다. <a href=\"https://miro.medium.com/max/2000/1*6HK361f-UDqNpWuTA68jHw.png\">번들 용량이 놀라울 정도로 작습니다</a>.</li>\n<li>Truly reactive : 복잡한 상태 관리 라이브러리 없이도, 쉽게 상태를 관리하고, 변화에 '반응'해서 빠르고 정확하게 UI를 변경합니다.</li>\n</ul>\n<p>다음은 이 블로그 게시글 목록에 있는 카드를 만드는 스벨트 컴포넌트입니다.</p>\n<pre><code class=\"language-html\">// BlogTeaser.svelte\n&#x3C;script>\n  export let blog; // 컴포넌트의 prop입니다.\n  export let helpers;\n\n  // ISO 포맷인 날짜를 사람이 읽을 수 있는 모양으로 변환합니다.\n  const formattedDate = new Intl.DateTimeFormat(\n    \"ko-KR\", {\n      dateStyle: \"long\",\n      timeStyle: \"short\"\n    })\n    .format(new Date(blog.frontmatter.date));\n&#x3C;/script>\n\n&#x3C;!-- 리액트처럼 {} 안에 js 코드를 넣을 수 있습니다. -->\n&#x3C;a href={helpers.permalinks.blog({ slug: blog.slug })}>\n&#x3C;div class=\"entry card\">\n    &#x3C;h3>{blog.frontmatter.title}&#x3C;/h3>\n  &#x3C;span class=\"date-badge\">\n    {formattedDate}\n  &#x3C;/span>\n  &#x3C;p>{blog.frontmatter.excerpt}&#x3C;/p>\n&#x3C;/div>\n&#x3C;/a>\n\n\n&#x3C;!--\ncss도 평범하게 사용하면 됩니다.\nscope가 해당 컴포넌트 안으로 제한되기 때문에\n복잡한 className 없이도 selector를 간단하게 유지할 수 있습니다.\n-->\n&#x3C;style>\n  span.date-badge {\n    color: gray;\n    font-size: 80%;\n    width: fit-content;\n  }\n\n  h3 {\n    margin: 0;\n    color: var(--primary);\n  }\n\n  p {\n    margin: 0.25rem;\n    color: var(--primary-text);\n  }\n&#x3C;/style>\n</code></pre>\n<p>Svelte 홈페이지에는 따로 설치 없이 바로 해볼 수 있는 <a href=\"https://svelte.dev/tutorial/basics\">영어 튜토리얼</a>이 있습니다.</p>\n<p>한국어 자료로는 <a href=\"https://heropy.blog/2019/09/29/svelte/\">Svete.js 완벽 가이드</a>도 있습니다. 저자 분이 인프런에서 유료 강의도 하고 계세요.</p>\n<h3 id=\"elderjs는-검색엔진에-최적화된-svelte-정적-사이트-생성기ssg입니다\">Elder.js는 검색엔진에 최적화된 Svelte 정적 사이트 생성기(SSG)입니다.</h3>\n<p><img src=\"https://github.com/elderjs/elderjs/raw/master/elderjs.png\" alt=\"할아버지를 그린 그림\"></p>\n<blockquote>\n<p>출처 : Elder.js 깃허브 배너. Elder.js는 노인 돌봄 서비스를 찾고 비교할 수 있는 https://elderguide.com 을 만들던 과정에서 탄생한 프레임워크다.</p>\n</blockquote>\n<p>Elder.js는 {{keyword}}CSR{{/keyword}}과 {{keyword}}SSR{{/keyword}}의 단점을 해결하기 위해 등장한 {{keyword}}JAM Stack{{/keyword}} 정적 사이트 생성기{{keyword}}SSG{{/keyword}}입니다. Elder.js 는 Svelte 앱을 정적인 HTML과 자그마한 컴포넌트로 분할해서 {{keyword}}Static File{{/keyword}}로 배포할 수 있게 해줍니다.</p>\n<p>{{keyword}}SEO{{/keyword}}는 블로그나 사이트를 만드는 사람이라면 신경 쓸 수 밖에 없죠. 구글이나 네이버의 크롤링 로봇들은 인터넷을 돌아다니면서 HTML 파일을 읽고 웹사이트에 어떤 내용이 있는지 정리합니다.</p>\n<p>하지만 React를 비롯한 {{keyword}}SPA{{/keyword}} 프레임워크들은 검색 엔진이 읽기 어려워합니다. 식당에서 음식을 고르려는데, 식재료와 레시피만 적혀 있는 것과 다르지 않습니다. 사용자의 웹 브라우저가 직접 html을 계산해야 하기 때문에 속도도 느리죠.</p>\n<p>그래서 서버에서 html을 렌더링하기도 합니다. 바로 {{keyword}}SSR{{/keyword}}이죠. React 기반인 Next.js가 대표적입니다. 하지만 SSR은 상대적으로 비싼 서버를 굴려야하기 때문에, 저희 같은 일반인은 물론이고 회사에게도 부담입니다.</p>\n<p>여기서 {{keyword}}JAM Stack{{/keyword}}이 등장합니다. 미리 가능한 페이지들을 정적(static) HTML 파일로 만들어서 CDN(콘텐츠 배달 네트워크)에 올려놓고, 추가로 필요한 데이터만 작은 API 서버에서 받아오게 하는 것이죠.</p>\n<p>이러면 Svelte나 React 같은 최신 프런트엔드 프레임워크를 사용하면서도, 가볍게 블로그나 사이트를 운영할 수 있습니다.</p>\n<p>이야기를 더 듣고 싶으시다면 <a href=\"https://twinstae.github.io/brief-history-of-web-front/\">웹 프런트 엔드의 간략한 역사</a>를 읽어주세요.</p>\n<p>Elder.js는 이러한 JAM 스택에서도 특히 SEO 전문가들이 만든 프레임워크입니다. 여러분의 블로그가 더 잘 검색될 수 있도록 사소한 것 하나하나 경고를 띄우고 Tip을 알려주죠. Sitemap등을 만들어주는 플러그인도 있습니다. 높은 조회수를 원하신다면, 정말 매력적인 셈이죠. :)</p>\n<p>이제 설명은 끝입니다. 실전으로 들어가보죠!</p>\n<h2 id=\"실전-elderjs-template-프로젝트-github-pages에-배포하기\">실전: Elder.js template 프로젝트 Github Pages에 배포하기</h2>\n<p>그러면 공식 가이드를 따라서, 프로젝트를 세팅해봅시다.</p>\n<p>앞서 말씀드렸듯 node.js와 함께 npm 이 설치되어 있어야합니다.</p>\n<p>잘 모르겠다면 명령 프롬프트나 터미널을 열고 다음 명령어를 쳐보세요.</p>\n<pre><code>npx --version\n# 6.14.12 이런 식으로 나오면 설치가 되어 있는 겁니다.\n</code></pre>\n<h3 id=\"npx로-elderjstemplate-세팅하기\">npx로 Elderjs/template 세팅하기</h3>\n<p>npx는 프로젝트 템플릿을 다운 받아 세팅해줍니다. 다음 명령어를 입력하면 &#x3C;내 깃허브 아이디>.github.io 라는 이름의 폴더와 기본 파일들이 생성됩니다.</p>\n<pre><code class=\"language-bash\">npx degit Elderjs/template &#x3C;내 깃허브 아이디>.github.io\n</code></pre>\n<p>저는 깃허브 아이디가 <code>twinstae</code> 이기 때문에 <code>twinstae.github.io</code>로 만들었습니다.</p>\n<p>이제 다음 명령어들을 차례차례 입력합니다. # 은 주석이니 무시하셔도 됩니다. 잘 모르는 터미널 명령어가 있다면 인터넷에 더 자세한 내용을 검색해보세요.</p>\n<pre><code class=\"language-bash\"># cd는 change directory의 줄임말입니다.\n# 방금 만든 프로젝트 폴더 안으로 이동합니다.\ncd &#x3C;내 깃허브 아이디>.github.io\n\n# package.json 파일에 적혀 있는 라이브러리들을 다운 받습니다.\n# svelte와 elder.js 등등의 모듈이 node_modules 폴더에 설치 됩니다.\n# yarn 을 사용한다면 yarn install도 가능합니다.\nnpm install\n\n# package.json에 있는 start 스크립트를 실행합니다.\n# dev 스크립트가 프로젝트를 빌드하고, 개발용 서버를 실행합니다.\nnpm start\n\n# 웹 브라우저에서 http://localhost:3000 으로 들어가면 사이트를 볼 수 있습니다.\nopen http://localhost:3000\n</code></pre>\n<p>정상적으로 프로젝트가 세팅이 되었다면, 웹 브라우저에서 다음과 같은 템플릿 사이트를 볼 수 있습니다.</p>\n<p><img src=\"https://res.cloudinary.com/practicaldev/image/fetch/s--A0xtvNLd--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_880/https://dev-to-uploads.s3.amazonaws.com/i/mksj4g4iuntzxkx5xdau.jpg\" alt=\"웹 브라우저에 Elder.js 템플릿 사이트가 열린 모습. Hello World: Welcome to Elder.js 라는 제목이 큰 글씨로 적혀 있다.\"></p>\n<p>개발용 localhost 서버는 내 컴퓨터에서만 볼 수 있습니다. 이제 저희 템플릿 프로젝트를 github pages에 올려서, 누구나 언제 어디서나 접속할 수 있게 만들어봅시다.</p>\n<p>영상이 편하신 분은 <a href=\"https://opentutorials.org/course/3084/18891\">생활코딩 WEBn 웹 호스팅</a> 강좌를 참고하세요. 약간 옛날 자료이긴 하지만 큰 개념을 잡는 데에는 무리가 없을 겁니다.</p>\n<h3 id=\"github-저장소-만들기\">github 저장소 만들기</h3>\n<p>깃허브에 가입하지 않으셨다면 먼저 <a href=\"https://github.com/signup\">회원가입</a>(Sign Up), 로그인(Sign In)을 해주세요.</p>\n<p>이제 저희 코드가 올라갈 클라우드 저장소(Repository)를 만들어야 합니다. 보통 줄여서 레포(Repo)라고도 부릅니다. 왼쪽 위에 보시면 다음과 같이 생긴 초록 버튼이 있습니다. 누르면 새 레포를 만드는 페이지가 나옵니다.</p>\n<p>{{githubNewRepoButton /}} 사실 이 버튼을 눌러도 바로 이동합니다.</p>\n<ol>\n<li>레포 이름은 앞서 정했던 <code>&#x3C;내 깃허브 아이디>.github.io</code> 로 합니다.</li>\n<li>Public과 Private가 있는데, Private로 하면 남들이 볼 수 없습니다. 사람들이 우리 사이트에 접속할 수 있게 하려면 Public을 선택합니다.</li>\n<li>README.md 파일이나 .gitignore 파일에 대해서는 다음 단계에서 설명합니다.</li>\n</ol>\n<p><img src=\"https://s3-ap-northeast-2.amazonaws.com/opentutorials-user-file/module/3135/7820.jpeg\" alt=\"깃허브 new repo 생성 페이지의 모습. repository name에 1, public/private 에 2, README 체크박스에 3이라는 번호가 적혀져 있다.\"></p>\n<h3 id=\"github-pages-설정하기\">github pages 설정하기</h3>\n<p>이제 저장소를 만들었으니, 저장소의 파일을 서빙하도록 설정해야 합니다.</p>\n<p>저장소 메뉴에 보면 Settings(설정)이 있습니다.\n<img src=\"https://docs.github.com/assets/images/help/repository/repo-actions-settings.png\" alt=\"Github 저장소 메뉴 사진. Settings 가 강조되어 있다.\"></p>\n<p>Pages 탭에 들어갑니다.</p>\n<p><img src=\"https://docs.github.com/assets/images/help/pages/pages-tab.png\" alt=\"설정의 메뉴 목록 사진. Pages가 강조되어 있다.\"></p>\n<p>Source 폴더를 <code>/(root)</code>에서 <code>/docs</code> 폴더로 바꾸고 저장(Save)해줍니다.</p>\n<p><img src=\"https://docs.github.com/assets/images/help/pages/publishing-source-folder-drop-down.png\" alt=\"source 폴더의 사진. 메뉴에 /root와 /docs가 있다.\"></p>\n<h3 id=\"gitignore로-용량이-큰-파일-보안에-민감한-파일-숨기기\">.gitignore로 용량이 큰 파일, 보안에 민감한 파일 숨기기</h3>\n<p>이제 아까 만들어둔 템플릿 프로젝트 폴더에 메모장이나 텍스트 에디터를 열고 <code>.gitignore</code> 라는 파일을 하나 만듭니다. txt 확장자로 저장하면 안 되고, 모든 파일 형식 으로 저장합니다.</p>\n<p>.gitignore에 적힌 파일이나 폴더는 remote 저장소에 올라가지 않게 됩니다. 저는 다음과 같이 3가지 폴더를 넣어주었습니다. 수정하고 저장합니다.</p>\n<ul>\n<li>node_modules는 용량이 크기 때문에</li>\n<li>___ELDER___는 컴파일된 중간 파일들이라서</li>\n<li>.env는 보안에 중요한 key 등이 들어가기 때문에 제외했습니다.</li>\n</ul>\n<pre><code class=\"language-text\"># .gitignore 파일 내용\n\nnode_modules\n___ELDER___\n.env\n</code></pre>\n<h3 id=\"nojekyll-파일-넣어서-asset-서빙되게-하기\">.nojekyll 파일 넣어서 asset 서빙되게 하기</h3>\n<p>Github Pages는 원래 Jekyll 이라는 루비 정적 사이트 생성기를 사용하는 게 기본입니다. 저희는 Elder.js 를 쓰기 때문에 .nojekyll 설정을 해줘야 합니다. 이 설정을 안 해주면 사이트 css나 이미지 같은 asset을 불러오지 못하게 됩니다. 디자인이 모두 날아간 황량한 HTML을 보지 않으려면...</p>\n<p>.nojekyll 파일을 만들어줍시다. 메모장으로 파일을 만들고 저장하면 됩니다. 내용은 비어 있어도 상관 없습니다.</p>\n<h3 id=\"배포되는-public-폴더-이름을-docs로-바꾸기\">배포되는 public 폴더 이름을 docs로 바꾸기</h3>\n<p>github pages는 root 폴더나 docs 라는 이름을 가진 폴더만 서빙할 수 있습니다. elder.js 는 기본적으로 public 폴더에 빌드된 html 파일들이 들어갑니다. 그렇기 때문에 설정을 바꿔서 docs 폴더에 들어가게 해줘야 합니다.</p>\n<p><code>elder.config.js</code> 파일을 텍스트 편집기로 열어보세요. 설정이 많지만 저희가 신경 쓸 건 딱 두 가지, 'origin'과 'distDir'입니다.</p>\n<p><code>origin</code>은 비어 있을 겁니다. 내 사이트의 host 도메인을 넣어줘야 하는데요. <code>https://&#x3C;내 깃허브 아이디>.github.io</code>를 적어주면 됩니다.</p>\n<p><code>distDir</code>은 <code>public</code>으로 되어 있을 겁니다. <code>docs</code> 로 바꿔줍니다.</p>\n<pre><code class=\"language-javascript\">module.exports = {\n  origin: 'https://&#x3C;내 깃허브 아이디>.github.io', // &#x3C;- 여기에 내 깃허브 pages 주소를 넣어줍니다.\n  lang: 'ko-KR',\n  srcDir: 'src',\n  distDir: 'docs', // &#x3C;- 여기를 docs로 바꿔 줍니다.\n  // 길어서 생략\n</code></pre>\n<h3 id=\"원격-저장소에-push-하기\">원격 저장소에 push 하기</h3>\n<p>이제 git으로 저희의 github 원격(remote) 저장소에 프로젝트를 올려보겠습니다. 혹시 빼먹고 넘어간 건 없는지 한 번 점검해보세요.</p>\n<p>문제가 없는 것 같다면 이제 터미널을 열고, 아까 저희가 만들어둔 템플릿 프로젝트 폴더로 이동합니다. cd 명령어를 이용하면 됩니다. 잘 모르겠다면 <a href=\"https://www.google.com/search?q=cd+%EB%AA%85%EB%A0%B9%EC%96%B4\">cd 명령어를 검색</a>해보세요</p>\n<p>이제 다음 명령어를 차례대로 실행합니다.</p>\n<pre><code class=\"language-bash\"># 현재 폴더를 깃 프로젝트로 설정합니다.\ngit init\n\n# 현재 폴더의 모든 파일을 git stage로 올려서 선택합니다.\ngit add .\n\n# stage에 선택된 파일들을 커밋해서 확정합니다.\ngit commit -m \"Initial commit\"\n\n# main 이라는 브랜치 버전을 만듭니다. \ngit branch -M main\n\n# 내 깃허브 원격 저장소를 추가해서 연결합니다.\ngit remote add origin https://github.com/&#x3C;내 깃허브 아이디>/&#x3C;내 깃허브 아이디>.github.io.git\n\n# 내 깃허브 원격 저장소에 커밋한 파일들을 올립니다!\ngit push -u origin main\n</code></pre>\n<p>성공적으로 push가 끝났으면, 내 github 페이지에 들어가서 파일이 잘 올라갔는지 확인합니다. 웹 브라우저 주소 창에 <code>https://&#x3C;내 깃허브 아이디>.github.io</code>를 치고 들어가면 됩니다.</p>\n<p>아까 localhost로 봤던 템플릿 사이트가 보이나요? 그러면 성공입니다!</p>\n<p>고생하셨습니다. 저희가 이번에 한 일을 정리해봅시다.</p>\n<ul>\n<li>Elder.js 템플릿 프로젝트를 세팅했습니다.</li>\n<li>템플릿 프로젝트를 Github 저장소에 올려서 배포했습니다.</li>\n</ul>\n<p>물론 이제 시작입니다. ;) 이제부터...</p>\n<ul>\n<li>블로그에 마크다운으로 글을 쓰는 방법</li>\n<li>내가 원하는대로 Layout, Home, Blog 의 디자인을 바꾸는 법</li>\n<li>다크모드, 날짜 순 정렬, 코드 문법 강조, Utterances 댓글 기능, 프로필 이미지 등을 넣는 법</li>\n<li>Elder.JS 의 작동 원리, 검색 엔진 최적화...</li>\n</ul>\n<p>그 밖에도 다양한 내용들을 차례차례 소개해보겠습니다. 궁금하신 게 있으면 댓글로 달아주세요.</p>","data":{"tocTree":[]},"permanlink":"/svelte-elder-create-blog/","tags":["Svelte","Elder.js","Github Pages","Blog"]}]};